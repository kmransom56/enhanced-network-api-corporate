<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="3D Network Topology Lab Viewer built with Babylon.js">
    <meta name="keywords" content="3D, Network, Topology, Lab, Viewer, Babylon.js, WebGL">
    <meta name="author" content="Your Name or Organization">
    <title>3D Network Topology Lab Viewer</title>
    <script src="/static/js/babylon.js"></script>
    <script src="/static/js/babylonjs.loaders.min.js"></script>
    <script src="/static/js/babylon.gui.min.js"></script>
    <style>
        /* Reuse the same layout and styling as babylon_topology.html for consistency */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0e1116 0%, #1a1f2e 100%);
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
            display: grid;
            grid-template-rows: 60px 1fr 40px;
            grid-template-columns: 0 1fr 0;
            grid-template-areas:
                "header header header"
                "sidebar main details"
                "status status status";
        }

        .top-toolbar {
            grid-area: header;
            background: rgba(30, 35, 50, 0.95);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(88, 166, 255, 0.3);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            z-index: 1000;
        }

        .toolbar-group {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 0 15px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .toolbar-group:last-child {
            border-right: none;
            margin-left: auto;
        }

        .toolbar-title {
            font-size: 18px;
            font-weight: 600;
            color: #58a6ff;
            margin-right: 20px;
        }

        .left-sidebar {
            grid-area: sidebar;
            background: rgba(30, 35, 50, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(88, 166, 255, 0.3);
            width: 280px;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            overflow-y: auto;
            z-index: 999;
        }

        .left-sidebar.open {
            transform: translateX(0);
        }

        .sidebar-toggle {
            position: absolute;
            left: 10px;
            top: 70px;
            background: rgba(88, 166, 255, 0.2);
            border: 1px solid rgba(88, 166, 255, 0.4);
            color: #58a6ff;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.3s ease;
        }

        .sidebar-toggle:hover {
            background: rgba(88, 166, 255, 0.3);
            transform: scale(1.05);
        }

        .main-canvas {
            grid-area: main;
            position: relative;
            width: 100%;
            height: 100%;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
        }

        #renderCanvas:active {
            cursor: grabbing;
        }

        .details-panel {
            grid-area: details;
            background: rgba(30, 35, 50, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(88, 166, 255, 0.3);
            width: 350px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            overflow-y: auto;
            z-index: 999;
        }

        .details-panel.open {
            transform: translateX(0);
        }

        .status-bar {
            grid-area: status;
            background: rgba(20, 25, 40, 0.95);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(88, 166, 255, 0.3);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 30px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-label {
            color: rgba(255, 255, 255, 0.5);
        }

        .status-value {
            color: #58a6ff;
            font-weight: 500;
        }

        .control-group {
            margin: 20px 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #58a6ff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button {
            background: linear-gradient(135deg, rgba(88, 166, 255, 0.2), rgba(88, 166, 255, 0.1));
            border: 1px solid rgba(88, 166, 255, 0.4);
            color: #ffffff;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        button:hover {
            background: linear-gradient(135deg, rgba(88, 166, 255, 0.3), rgba(88, 166, 255, 0.2));
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(88, 166, 255, 0.2);
        }

        button:active {
            transform: translateY(0);
        }

        button.active {
            background: linear-gradient(135deg, rgba(88, 166, 255, 0.4), rgba(88, 166, 255, 0.3));
            border-color: #58a6ff;
        }

        .data-source-buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .data-source-buttons button {
            flex: 1;
            font-size: 12px;
            padding: 6px 8px;
        }

        #deviceInfo {
            padding: 20px;
        }

        #deviceInfo.hidden {
            display: none;
        }

        .device-details {
            font-size: 13px;
            line-height: 1.5;
        }

        .device-details h4 {
            color: #58a6ff;
            margin: 0 0 15px 0;
            font-size: 16px;
            border-bottom: 1px solid rgba(88, 166, 255, 0.3);
            padding-bottom: 10px;
        }

        .label {
            color: rgba(255, 255, 255, 0.6);
            font-weight: 500;
        }

        .value {
            color: #ffffff;
            margin-left: 5px;
        }

        #loading,
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(30, 35, 50, 0.95);
            padding: 30px;
            border-radius: 12px;
            border: 1px solid rgba(88, 166, 255, 0.3);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            z-index: 2000;
        }

        .hidden {
            display: none;
        }

        .device-tooltip {
            position: fixed;
            padding: 8px 12px;
            background: rgba(15, 20, 35, 0.95);
            border-radius: 6px;
            border: 1px solid rgba(88, 166, 255, 0.8);
            color: #ffffff;
            font-size: 12px;
            pointer-events: none;
            transform: translate(-50%, -120%);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            z-index: 2500;
            white-space: nowrap;
        }

        @media (max-width: 1200px) {
            .details-panel {
                width: 300px;
            }
        }

        @media (max-width: 768px) {
            body {
                grid-template-columns: 1fr;
                grid-template-areas:
                    "header header"
                    "main main"
                    "status status";
            }

            .left-sidebar,
            .details-panel {
                position: fixed;
                top: 60px;
                height: calc(100vh - 100px);
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }

            .details-panel {
                right: 0;
                width: 100%;
                max-width: 350px;
            }
        }
    </style>
</head>

<body>
    <header class="top-toolbar">
        <div class="toolbar-title">üß™ 3D Network Topology Lab</div>
        <div class="toolbar-group">
            <button id="loadTopologyBtn">üåê Load Lab Topology</button>
            <button id="resetViewBtn">üì∑ Reset View</button>
        </div>
        <div class="toolbar-group">
            <button id="autoRotateBtn">üîÑ Auto-Rotate</button>
            <button id="labelsBtn">üè∑Ô∏è Labels</button>
        </div>
        <div class="toolbar-group">
            <button id="exportDrawIOXmlBtn">üßæ Export DrawIO XML</button>
            <button id="exportDrawIO3DSceneBtn">üéÆ Export 3D JSON</button>
        </div>
        <div class="toolbar-group">
            <span class="status-label">Status:</span>
            <span id="statusText" class="status-value">Ready</span>
        </div>
    </header>

    <button class="sidebar-toggle" id="sidebarToggle">‚ò∞</button>

    <aside class="left-sidebar" id="leftSidebar">
        <div class="control-group">
            <h3>Data Source</h3>
            <p style="font-size: 12px; color: rgba(255,255,255,0.7);">
                Using <code>/api/topology/babylon-lab-format</code> from Enhanced Network API.
            </p>
        </div>
    </aside>

    <main class="main-canvas">
        <canvas id="renderCanvas"></canvas>

        <!-- Debug Log -->
        <div id="debugLog"
            style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8); color: lime; font-family: monospace; padding: 10px; max-height: 300px; overflow-y: auto; z-index: 3000; pointer-events: none; width: 400px;">
            <div>Debug Log:</div>
        </div>

        <!-- Loading Overlay -->
        <div id="loading" class="hidden">
            <div>üîÑ Loading topology...</div>
        </div>

        <!-- Error Overlay -->
        <div id="error" class="hidden">
            <div>‚ùå <span id="errorMessage">Error loading topology</span></div>
        </div>
        <!-- Hover tooltip for device info -->
        <div id="deviceTooltip" class="device-tooltip hidden"></div>
    </main>

    <aside class="details-panel" id="deviceInfo">
        <div id="deviceDetails">
            <div class="device-details">
                <h4>üìã Device Details</h4>
                <p>Select a device to view details...</p>
            </div>
        </div>
    </aside>

    <footer class="status-bar">
        <div class="status-item">
            <span class="status-label">üéØ FPS:</span>
            <span id="fpsCounter" class="status-value">60</span>
        </div>
        <div class="status-item">
            <span class="status-label">üì¶ Objects:</span>
            <span id="objectCounter" class="status-value">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">üîó Devices:</span>
            <span id="deviceCounter" class="status-value">0</span>
        </div>
    </footer>

    <script>
        let engine, scene, camera;
        let devices = [];
        let links = [];
        let autoRotate = false;
        let tooltipEl = null;
        let labelsVisible = true;
        let deviceLabels = [];

        function showLoading() {
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('error').classList.add('hidden');
        }

        function hideLoading() {
            document.getElementById('loading').classList.add('hidden');
        }

        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('error').classList.remove('hidden');
            document.getElementById('loading').classList.add('hidden');
        }

        function updateStatus(status) {
            document.getElementById('statusText').textContent = status;
        }

        function updateStats() {
            if (!scene || !engine) return;
            const fpsCounter = document.getElementById('fpsCounter');
            const objectCounter = document.getElementById('objectCounter');
            const deviceCounter = document.getElementById('deviceCounter');
            if (fpsCounter) fpsCounter.textContent = Math.round(engine.getFps());
            if (objectCounter) objectCounter.textContent = scene.meshes.length;
            if (deviceCounter) deviceCounter.textContent = devices.length;
        }


        function fitCameraToNodes(nodes) {
            if (!camera || !nodes || !nodes.length) return;

            let minX = Infinity, maxX = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            nodes.forEach((n) => {
                if (!n.position) return;
                const x = typeof n.position.x === 'number' ? n.position.x : 0;
                const z = typeof n.position.z === 'number' ? n.position.z : 0;
                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (z < minZ) minZ = z;
                if (z > maxZ) maxZ = z;
            });

            if (!isFinite(minX) || !isFinite(maxX) || !isFinite(minZ) || !isFinite(maxZ)) {
                return;
            }
            // Compute center and extent
            const centerX = (minX + maxX) / 2;
            const centerZ = (minZ + maxZ) / 2;
            const extent = Math.max(maxX - minX, maxZ - minZ, 10);
            const radius = extent * 2.5;

            camera.target = new BABYLON.Vector3(centerX, 0, centerZ);
            camera.radius = radius;
            camera.beta = Math.PI / 3; // Keep a comfortable tilt
        }

        function showTooltip(deviceData, clientX, clientY) {
            if (!tooltipEl) return;
            const name = deviceData.name || 'Unknown Device';
            const ip = deviceData.ip || 'N/A';
            const type = deviceData.deviceType || deviceData.type || '';
            const mac = deviceData.mac || '';
            const vendor = deviceData.vendor || deviceData.device_vendor || '';
            const vlan = deviceData.vlan || '';

            let html = `<strong>${name}</strong>`;
            if (ip) {
                html += `<br>IP: ${ip}`;
            }
            if (type) {
                html += `<br>Type: ${type}`;
            }
            if (vendor) {
                html += `<br>Vendor: ${vendor}`;
            }
            if (mac) {
                html += `<br>MAC: ${mac}`;
            }
            if (vlan) {
                html += `<br>VLAN: ${vlan}`;
            }
            tooltipEl.innerHTML = html;
            tooltipEl.style.left = clientX + 'px';
            tooltipEl.style.top = clientY + 'px';
            tooltipEl.classList.remove('hidden');
        }

        function hideTooltip() {
            if (!tooltipEl) return;
            tooltipEl.classList.add('hidden');
        }

        function logDebug(msg) {
            console.log(msg);
            const log = document.getElementById('debugLog');
            if (log) {
                const line = document.createElement('div');
                line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
                log.appendChild(line);
                log.scrollTop = log.scrollHeight;
            }
        }

        // Initialize Babylon.js
        function initBabylon() {
            try {
                logDebug('üéÆ Initializing Babylon.js...');

                const canvas = document.getElementById('renderCanvas');
                if (!canvas) {
                    throw new Error('Canvas element not found');
                }

                logDebug('‚úÖ Canvas found');

                // Check for WebGL support explicitly
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) {
                    throw new Error('WebGL not supported');
                }

                // Set canvas dimensions
                canvas.width = canvas.parentElement.clientWidth;
                canvas.height = canvas.parentElement.clientHeight;

                // Create engine
                engine = new BABYLON.Engine(canvas, true);
                window.engine = engine;
                if (!engine) {
                    throw new Error('Failed to create Babylon.js engine');
                }

                logDebug('‚úÖ Babylon.js engine created');

                scene = new BABYLON.Scene(engine);
                window.scene = scene;
                if (!scene) {
                    throw new Error('Failed to create Babylon.js scene');
                }

                logDebug('‚úÖ Babylon.js scene created');

                // Set background
                const manager = new BABYLON.GUI.GUI3DManager(scene);

                // ------------------------------------------------------------
                // 3D GUI ‚Äì Topology Control Panel (floating in the scene)
                // ------------------------------------------------------------
                const topoPanel = new BABYLON.GUI.StackPanel3D();
                topoPanel.isVertical = true;
                topoPanel.margin = 0.02;
                topoPanel.width = 2;
                topoPanel.height = 3;
                topoPanel.position = new BABYLON.Vector3(0, 2.5, -5);
                manager.addControl(topoPanel);

                // Helper to create a 3D button
                function make3DButton(name, label, onClick) {
                    const btn = new BABYLON.GUI.Button3D(name);
                    const txt = new BABYLON.GUI.TextBlock();
                    txt.text = label;
                    txt.color = 'white';
                    btn.content = txt;
                    btn.onPointerUpObservable.add(onClick);
                    return btn;
                }

                // Reset View button
                topoPanel.addControl(make3DButton('reset3d', 'Reset View', () => {
                    if (camera) {
                        camera.alpha = 0;
                        camera.beta = Math.PI / 3;
                        camera.radius = 30;
                        logDebug('üîÅ 3‚ÄëD Reset button pressed');
                    }
                }));

                // Auto‚Äërotate toggle
                let autoRotate = false;
                topoPanel.addControl(make3DButton('autoRotate', 'Auto‚ÄëRotate', () => {
                    autoRotate = !autoRotate;
                    logDebug(`üîÑ Auto‚Äërotate ${autoRotate ? 'ON' : 'OFF'}`);
                }));

                // Labels toggle (checkbox style)
                const labelToggle = new BABYLON.GUI.Checkbox();
                labelToggle.isChecked = true;
                labelToggle.onIsCheckedChangedObservable.add(state => {
                    labelsVisible = state;
                    deviceLabels.forEach(l => l.isVisible = state);
                    logDebug(`üè∑Ô∏è Labels ${state ? 'shown' : 'hidden'}`);
                });
                const labelRow = new BABYLON.GUI.StackPanel3D();
                labelRow.isVertical = false;
                labelRow.addControl(labelToggle);
                const lblTxt = new BABYLON.GUI.TextBlock();
                lblTxt.text = 'Show Labels';
                lblTxt.color = 'white';
                labelRow.addControl(lblTxt);
                topoPanel.addControl(labelRow);

                // Device‚Äëtype filter (radio group)
                const typeGroup = new BABYLON.GUI.RadioGroup('typeFilter');
                typeGroup.addRadio('All', () => filterDevices('all'), true);
                typeGroup.addRadio('Switches', () => filterDevices('switch'));
                typeGroup.addRadio('Routers', () => filterDevices('router'));
                typeGroup.addRadio('Servers', () => filterDevices('server'));
                const typePanel = new BABYLON.GUI.StackPanel3D();
                typePanel.isVertical = true;
                const typeHeader = new BABYLON.GUI.TextBlock();
                typeHeader.text = 'Device Type';
                typeHeader.color = 'white';
                typePanel.addControl(typeHeader);
                typePanel.addControl(typeGroup);
                topoPanel.addControl(typePanel);

                // Vendor filter (checkbox group)
                const vendorGroup = new BABYLON.GUI.CheckboxGroup('Vendor');
                vendorGroup.addCheckbox('Cisco', v => filterVendor('cisco', v));
                vendorGroup.addCheckbox('Fortinet', v => filterVendor('fortinet', v));
                vendorGroup.addCheckbox('Juniper', v => filterVendor('juniper', v));
                const vendorPanel = new BABYLON.GUI.StackPanel3D();
                vendorPanel.isVertical = true;
                const vendorHeader = new BABYLON.GUI.TextBlock();
                vendorHeader.text = 'Vendor';
                vendorHeader.color = 'white';
                vendorPanel.addControl(vendorHeader);
                vendorPanel.addControl(vendorGroup);
                topoPanel.addControl(vendorPanel);

                // ------------------------------------------------------------
                // HolographicSlate ‚Äì device detail panel (appears near selected device)
                // ------------------------------------------------------------
                const detailSlate = new BABYLON.GUI.HolographicSlate('detailSlate');
                detailSlate.title = 'Device Details';
                detailSlate.titleBarHeight = 0.5;
                detailSlate.dimensions = new BABYLON.Vector2(4, 2);
                manager.addControl(detailSlate);
                detailSlate.position = new BABYLON.Vector3(0, 4, 0);
                const slateTex = new BABYLON.GUI.AdvancedDynamicTexture.CreateForMesh(detailSlate.mesh, 1024, 512);
                detailSlate.content = slateTex;
                function populateDetailSlate(node) {
                    slateTex.clear();
                    const title = new BABYLON.GUI.TextBlock();
                    title.text = `${node.name || 'Device'} (${node.type || ''})`;
                    title.fontSize = 24;
                    title.color = '#58a6ff';
                    title.height = '40px';
                    title.textHorizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER;
                    slateTex.addControl(title);
                    const info = new BABYLON.GUI.StackPanel();
                    info.isVertical = true;
                    info.marginTop = '10px';
                    const addRow = (label, value) => {
                        const row = new BABYLON.GUI.StackPanel();
                        row.isVertical = false;
                        const lbl = new BABYLON.GUI.TextBlock();
                        lbl.text = `${label}:`;
                        lbl.width = '80px';
                        lbl.color = 'rgba(255,255,255,0.6)';
                        const val = new BABYLON.GUI.TextBlock();
                        val.text = value ?? '‚Äî';
                        val.color = 'white';
                        row.addControl(lbl);
                        row.addControl(val);
                        info.addControl(row);
                    };
                    addRow('IP', node.ip);
                    addRow('MAC', node.mac);
                    addRow('Vendor', node.vendor);
                    addRow('Model', node.model);
                    addRow('Status', node.status);
                    slateTex.addControl(info);
                }
                function showDeviceInfo(node) {
                    if (!node) return;
                    detailSlate.position = node.mesh.getAbsolutePosition().add(new BABYLON.Vector3(0, 2, 0));
                    populateDetailSlate(node);
                    detailSlate.isVisible = true;
                }

                // ------------------------------------------------------------
                // Filtering helper functions (device type & vendor)
                // ------------------------------------------------------------
                function filterDevices(mode) {
                    // mode: 'all' | 'switch' | 'router' | 'server'
                    nodes.forEach(n => {
                        if (!n.mesh) return;
                        const visible = (mode === 'all') || (n.type && n.type.toLowerCase() === mode);
                        n.mesh.setEnabled(visible);
                        if (n.label) n.label.isVisible = visible && labelsVisible;
                    });
                    logDebug(`üîé Device filter: ${mode}`);
                }
                function filterVendor(vendorKey, isChecked) {
                    nodes.forEach(n => {
                        if (!n.mesh) return;
                        const match = n.vendor && n.vendor.toLowerCase().includes(vendorKey);
                        const visible = isChecked ? match : !match;
                        // Combine with current type filter ‚Äì we only toggle the vendor flag
                        if (visible) n.mesh.setEnabled(true);
                        else n.mesh.setEnabled(false);
                        if (n.label) n.label.isVisible = visible && labelsVisible;
                    });
                    logDebug(`üîé Vendor ${vendorKey} ${isChecked ? 'ON' : 'OFF'}`);
                }
                scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.1, 1.0);

                // Create camera
                camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI / 3, 30, BABYLON.Vector3.Zero(), scene);
                window.camera = camera;
                camera.attachControl(canvas, true);
                camera.lowerRadiusLimit = 10;
                camera.upperRadiusLimit = 100;

                logDebug('‚úÖ Camera created');

                // Create lights
                const light1 = new BABYLON.HemisphericLight('light1', new BABYLON.Vector3(0, 1, 0), scene);
                light1.intensity = 0.7;

                const light2 = new BABYLON.DirectionalLight('light2', new BABYLON.Vector3(-1, -2, -1), scene);
                light2.position = new BABYLON.Vector3(20, 40, 20);
                light2.intensity = 0.5;

                logDebug('‚úÖ Lighting created');

                // Create ground with textured material
                const ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 40, height: 40 }, scene);
                const groundMaterial = new BABYLON.StandardMaterial('groundMaterial', scene);
                groundMaterial.diffuseTexture = new BABYLON.Texture('/static/img/ground.jpg', scene);
                groundMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
                ground.material = groundMaterial;
                // Add skybox
                const skybox = BABYLON.MeshBuilder.CreateBox('skyBox', { size: 1000.0 }, scene);
                const skyboxMaterial = new BABYLON.StandardMaterial('skyBoxMaterial', scene);
                skyboxMaterial.backFaceCulling = false;
                skyboxMaterial.disableLighting = true;
                skyboxMaterial.diffuseColor = new BABYLON.Color3(0, 0, 0);
                skyboxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
                skyboxMaterial.reflectionTexture = new BABYLON.CubeTexture('/static/img/skybox/skybox', scene);
                skyboxMaterial.reflectionTexture.coordinatesMode = BABYLON.Texture.SKYBOX_MODE;
                skybox.material = skyboxMaterial;
                // Fog
                scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
                scene.fogDensity = 0.02;
                scene.fogColor = new BABYLON.Color3(0.05, 0.05, 0.1);
                // Bloom effect
                const bloom = new BABYLON.BloomEffect(scene);
                // Directional light with shadows
                const dirLight = new BABYLON.DirectionalLight('dirLight', new BABYLON.Vector3(-1, -2, -1), scene);
                dirLight.position = new BABYLON.Vector3(20, 40, 20);
                dirLight.intensity = 0.6;
                const shadowGenerator = new BABYLON.ShadowGenerator(1024, dirLight);
                shadowGenerator.useExponentialShadowMap = true;
                // Add to ground and grid to receive shadows
                ground.receiveShadows = true;
                // Ensure meshes will cast shadows later when loaded

                // Create grid
                const gridMaterial = new BABYLON.StandardMaterial('gridMaterial', scene);
                gridMaterial.wireframe = true;
                gridMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.3, 0.4);
                gridMaterial.emissiveColor = new BABYLON.Color3(0.1, 0.15, 0.2);

                const grid = BABYLON.MeshBuilder.CreateGround('grid', { width: 40, height: 40, subdivisions: 20 }, scene);
                grid.material = gridMaterial;
                grid.position.y = 0.01;
                ```
                logDebug('‚úÖ Ground and grid created');

                // Handle pointer events (selection & hover)
                scene.onPointerObservable.add((pointerInfo) => {
                    if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERPICK) {
                        if (pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh) {
                            const pickedMesh = pointerInfo.pickInfo.pickedMesh;

                            // Highlight selection
                            if (pickedMesh.metadata && !pickedMesh.parent) {
                                // Remove previous highlights
                                scene.meshes.forEach(m => { if (m.highlightLayer) m.highlightLayer.removeMesh(m); });
                                // Add highlight layer if not exists
                                if (!scene.highlightLayer) {
                                    scene.highlightLayer = new BABYLON.HighlightLayer('hl1', scene);
                                }
                                scene.highlightLayer.addMesh(pickedMesh, BABYLON.Color3.Yellow());
                                // Show device details in the holographic slate
                                showDeviceInfo(pickedMesh.metadata);
                                logDebug('üîç Device selected: ' + pickedMesh.metadata.name);
                            }
                        }
                    } else if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERMOVE) {
                        // Hover tooltip
                        if (pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh) {
                            const hovered = pointerInfo.pickInfo.pickedMesh;
                            if (hovered.metadata) {
                                showTooltip(hovered.metadata, pointerInfo.event.clientX, pointerInfo.event.clientY);
                            }
                        } else {
                            hideTooltip();
                        }
                    }
                });

                // Start render loop
                engine.runRenderLoop(() => {
                    try {
                        if (autoRotate && camera) {
                            camera.alpha += 0.005;
                        }
                        if (scene) {
                            scene.render();
                        }
                        updateStats();
                    } catch (error) {
                        console.error('‚ùå Render loop error:', error);
                    }
                });

                logDebug('‚úÖ Render loop started');
                // GUI Controls (Full‚Äëscreen UI)
                const gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('ui');
                // Reset View button (already exists in HTML, but add shortcut)
                const resetBtn = BABYLON.GUI.Button.CreateSimpleButton('resetBtn', 'üì∑ Reset View');
                resetBtn.width = '120px';
                resetBtn.height = '40px';
                resetBtn.cornerRadius = 6;
                resetBtn.color = 'white';
                resetBtn.background = '#58a6ff';
                resetBtn.onPointerUpObservable.add(() => {
                    if (camera) {
                        camera.alpha = 0;
                        camera.beta = Math.PI / 3;
                        camera.radius = 30;
                    }
                });
                gui.addControl(resetBtn);
                resetBtn.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
                resetBtn.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                resetBtn.top = '10px';
                resetBtn.left = '-10px';
                // Auto‚Äërotate toggle
                const autoRotateBtn = BABYLON.GUI.Button.CreateSimpleButton('autoRotateBtn', 'üîÑ Auto‚ÄëRotate');
                autoRotateBtn.width = '120px';
                autoRotateBtn.height = '40px';
                autoRotateBtn.cornerRadius = 6;
                autoRotateBtn.color = 'white';
                autoRotateBtn.background = '#58a6ff';
                autoRotateBtn.onPointerUpObservable.add(() => {
                    autoRotate = !autoRotate;
                    autoRotateBtn.background = autoRotate ? '#ff7b72' : '#58a6ff';
                });
                gui.addControl(autoRotateBtn);
                autoRotateBtn.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
                autoRotateBtn.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                autoRotateBtn.top = '60px';
                autoRotateBtn.left = '-10px';
                // Labels toggle
                const labelsBtn = BABYLON.GUI.Button.CreateSimpleButton('labelsBtn', 'üè∑Ô∏è Labels');
                labelsBtn.width = '120px';
                labelsBtn.height = '40px';
                labelsBtn.cornerRadius = 6;
                labelsBtn.color = 'white';
                labelsBtn.background = '#58a6ff';
                labelsBtn.onPointerUpObservable.add(() => {
                    labelsVisible = !labelsVisible;
                    deviceLabels.forEach(lbl => lbl.isVisible = labelsVisible);
                    labelsBtn.background = labelsVisible ? '#ff7b72' : '#58a6ff';
                });
                gui.addControl(labelsBtn);
                labelsBtn.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
                labelsBtn.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
                labelsBtn.top = '110px';
                labelsBtn.left = '-10px';

                // Handle window resize
                window.addEventListener('resize', () => {
                    if (engine) {
                        engine.resize();
                    }
                });

                window.babylonReady = true;

            } catch (error) {
                console.error('‚ùå Failed to initialize Babylon.js:', error);
                logDebug('‚ùå Init Error: ' + error.message);

                // Show user-friendly error with 2D fallback option
                const errorDiv = document.getElementById('error');
                const errorMessage = document.getElementById('errorMessage');
                const loading = document.getElementById('loading');

                if (loading) loading.classList.add('hidden');
                if (errorDiv) {
                    errorDiv.classList.remove('hidden');
                    errorDiv.innerHTML = `
                    < div style = "text-align: center;" >
                            <h3 style="color: #ff5555; margin-bottom: 10px;">‚ùå 3D Engine Error</h3>
                            <p>${error.message}</p>
                            <p style="margin-top: 15px; font-size: 14px; color: #aaa;">
                                Your browser or environment does not support WebGL, which is required for 3D visualization.
                            </p>
                            <a href="/static/2d_topology_enhanced.html" style="display: inline-block; margin-top: 20px; padding: 10px 20px; background: #58a6ff; color: white; text-decoration: none; border-radius: 5px; font-weight: bold;">
                                ‚û°Ô∏è Switch to 2D View
                            </a>
                        </div >
                    `;
                }
            }
        }

        // UI Functions
        function showLoading() {
            const loading = document.getElementById('loading');
            const error = document.getElementById('error');
            if (loading) loading.classList.remove('hidden');
            if (error) error.classList.add('hidden');
        }

        function hideLoading() {
            const loading = document.getElementById('loading');
            if (loading) loading.classList.add('hidden');
        }

        function showError(message) {
            const errorMessage = document.getElementById('errorMessage');
            const error = document.getElementById('error');
            const loading = document.getElementById('loading');
            if (errorMessage) errorMessage.textContent = message;
            if (error) error.classList.remove('hidden');
            if (loading) loading.classList.add('hidden');
            logDebug('‚ùå Error: ' + message);
        }

        function hideError() {
            document.getElementById('error').classList.add('hidden');
        }

        function updateStatus(status) {
            const statusText = document.getElementById('statusText');
            const sceneStatus = document.getElementById('sceneStatus');
            if (statusText) statusText.textContent = status;
            if (sceneStatus) sceneStatus.textContent = status;
            logDebug('Status: ' + status);
        }

        function updateStats() {
            if (scene) {
                const fpsCounter = document.getElementById('fpsCounter');
                const objectCounter = document.getElementById('objectCounter');
                const deviceCounter = document.getElementById('deviceCounter');

                if (fpsCounter) fpsCounter.textContent = Math.round(engine.getFps());
                if (objectCounter) objectCounter.textContent = scene.meshes.length;
                if (deviceCounter) deviceCounter.textContent = devices.length;
            }
        }

        function showDeviceInfo(deviceData) {
            const deviceInfo = document.getElementById('deviceInfo');
            const deviceDetails = document.getElementById('deviceDetails');

            if (!deviceInfo || !deviceDetails) return;

            deviceInfo.classList.add('open');

            let detailsHTML = `< div class="device-details" > `;
            detailsHTML += `< h4 >üìã ${ deviceData.name || 'Unknown Device' }</h4 > `;

            detailsHTML += `< div style = "margin-bottom: 15px;" > `;
            detailsHTML += `< h5 > Device Information</h5 > `;
            detailsHTML += `< div ><span class="label">Type:</span> <span class="value">${deviceData.deviceType || deviceData.type || 'Unknown'}</span></div > `;
            detailsHTML += `< div ><span class="label">Vendor:</span> <span class="value">${deviceData.deviceVendor || 'Unknown'}</span></div > `;
            detailsHTML += `< div ><span class="label">Model:</span> <span class="value">${deviceData.model || 'Unknown'}</span></div > `;
            detailsHTML += `< div ><span class="label">IP:</span> <span class="value">${deviceData.ip || 'N/A'}</span></div > `;
            detailsHTML += `< div ><span class="label">Status:</span> <span class="value">${deviceData.status || 'Unknown'}</span></div > `;
            if (deviceData.mac) detailsHTML += `< div ><span class="label">MAC:</span> <span class="value">${deviceData.mac}</span></div > `;
            detailsHTML += `</div > `;

            // Show enhanced device information if available
            if (deviceData.deviceModel || deviceData.device_confidence) {
                detailsHTML += `< div style = "margin-bottom: 15px;" > `;
                detailsHTML += `< h5 > Device Recognition</h5 > `;
                if (deviceData.deviceModel) {
                    detailsHTML += `< div ><span class="label">3D Model:</span> <span class="value">${deviceData.deviceModel}</span></div > `;
                }
                if (deviceData.device_confidence) {
                    detailsHTML += `< div ><span class="label">Match Confidence:</span> <span class="value">${deviceData.device_confidence}</span></div > `;
                }
                if (deviceData.pos_system) {
                    detailsHTML += `< div ><span class="label">POS System:</span> <span class="value">${deviceData.pos_system}</span></div > `;
                }
                detailsHTML += `</div > `;
            }

            if (deviceData.health) {
                detailsHTML += `< div style = "margin-bottom: 15px;" > `;
                detailsHTML += `< h5 > Health & Performance</h5 > `;
                detailsHTML += `< div ><span class="label">Health:</span> <span class="value">${deviceData.health}</span></div > `;
                if (deviceData.cpu) detailsHTML += `< div ><span class="label">CPU:</span> <span class="value">${deviceData.cpu}</span></div > `;
                if (deviceData.memory) detailsHTML += `< div ><span class="label">Memory:</span> <span class="value">${deviceData.memory}</span></div > `;
                detailsHTML += `</div > `;
            }

            detailsHTML += `</div > `;
            deviceDetails.innerHTML = detailsHTML;
        }

        async function loadTopologyFromLab() {
            updateStatus('Loading...');
            showLoading();
            try {
                logDebug('üì° Fetching topology data...');
                const resp = await fetch('/api/topology/babylon-lab-format');
                if (!resp.ok) {
                    const text = await resp.text();
                    throw new Error('HTTP ' + resp.status + ': ' + text);
                }
                const lab = await resp.json();
                logDebug('‚úÖ Topology data received. Nodes: ' + (lab.models ? lab.models.length : 0));

                const models = lab.models || [];
                const connections = lab.connections || [];

                const nodes = models.map(function (m, idx) {
                    return {
                        id: m.id || ('node-' + idx),
                        name: m.name,
                        type: m.type,
                        device_type: m.type,
                        device_vendor: m.vendor,
                        vendor: m.vendor,
                        model: m.model,
                        icon_svg: m.icon_svg,
                        ip: m.ip,
                        mac: m.mac,
                        vlan: m.vlan,
                        status: m.status || 'online',
                        position: m.position || null,
                        // placeholder for mesh reference
                        mesh: null,
                        // placeholder for label GUI
                        label: null
                    };
                });

                const links = connections.map(function (c, idx) {
                    return {
                        id: c.id || ('link-' + idx),
                        from: c.from,
                        to: c.to,
                        status: c.status,
                        protocol: c.protocol,
                        bandwidth: c.bandwidth,
                        vlan: c.vlan
                    };
                });

                await renderTopology({ nodes: nodes, links: links });
                // Center and zoom camera so all nodes are comfortably in view
                fitCameraToNodes(nodes);
                updateStatus('Loaded');
                logDebug('‚úÖ Topology loaded successfully');
            } catch (err) {
                console.error('Failed to load lab topology:', err);
                showError(err.message || String(err));
                updateStatus('Error');
            } finally {
                hideLoading();
            }
        }

        async function renderTopology(data) {
            // Clear existing devices and links
            devices.forEach(d => d.dispose && d.dispose());
            devices = [];
            links.forEach(l => l.dispose && l.dispose());
            links = [];
            deviceLabels = [];

            // Render links first
            data.links.forEach(function (linkData, index) {
                const sourceNode = data.nodes.find(function (n) { return n.id === linkData.from; });
                const targetNode = data.nodes.find(function (n) { return n.id === linkData.to; });
                if (!sourceNode || !targetNode) return;

                const sourcePos = new BABYLON.Vector3(
                    (sourceNode.position && sourceNode.position.x) || 0,
                    0.5,
                    (sourceNode.position && sourceNode.position.z) || 0
                );
                const targetPos = new BABYLON.Vector3(
                    (targetNode.position && targetNode.position.x) || 0,
                    0.5,
                    (targetNode.position && targetNode.position.z) || 0
                );

                const line = BABYLON.MeshBuilder.CreateLines(`link_${ index } `, {
                    points: [sourcePos, targetPos]
                }, scene);
                line.color = new BABYLON.Color3(0.7, 0.7, 0.7);
                links.push(line);
            });

            // Render devices with actual 3D models and 2D SVG overlays
            // Render devices with actual 3D models and 2D SVG overlays
            for (let index = 0; index < data.nodes.length; index++) {
                const nodeData = data.nodes[index];
                const hasPos = nodeData.position && typeof nodeData.position.x === 'number' && typeof nodeData.position.z === 'number';
                const position = new BABYLON.Vector3(
                    hasPos ? nodeData.position.x : (index % 5) * 4 - 8,
                    hasPos && typeof nodeData.position.y === 'number' ? nodeData.position.y : 1,
                    hasPos ? nodeData.position.z : Math.floor(index / 5) * 4 - 8
                );

                // Try to load actual 3D model first
                let mesh = await loadDeviceModel(nodeData, position);

                // Fallback to device-specific box if model loading fails
                if (!mesh) {
                    console.log('Falling back to box for', nodeData.name);
                    mesh = createDeviceBox(nodeData, position);
                }

                // Add 2D SVG overlay/sprite
                await addSVGOverlay(nodeData, mesh);

                // Add label with device name and IP under the icon
                createDeviceLabel(nodeData, mesh);

                devices.push(mesh);
            }
        }

        let labModelManifest = null;


        async function loadLabModelManifest() {
            if (labModelManifest) return labModelManifest;
            try {
                const resp = await fetch('/lab_3d_models/manifest.json');
                if (!resp.ok) {
                    throw new Error('HTTP ' + resp.status);
                }
                const data = await resp.json();
                labModelManifest = data && Array.isArray(data.models) ? data : { models: [] };
            } catch (e) {
                console.log('Failed to load lab_3d_models manifest:', e);
                labModelManifest = { models: [] };
            }
            return labModelManifest;
        }


        function selectModelFromManifest(nodeData, manifest) {
            if (!manifest || !Array.isArray(manifest.models)) return null;

            const dt = (nodeData.type || nodeData.device_type || '').toLowerCase();
            let preferredCategories = [];
            if (dt.includes('fortigate') || dt.includes('firewall') || dt.includes('gateway')) {
                preferredCategories = ['firewall', 'security'];
            } else if (dt.includes('fortiswitch') || dt === 'switch') {
                preferredCategories = ['switch'];
            } else if (dt.includes('fortiap') || dt.includes('access_point') || dt.includes('wifi') || dt === 'ap') {
                preferredCategories = ['access_point'];
            }

            function matches(model) {
                const cat = String(model.category || '').toLowerCase();
                const name = String(model.name || '').toLowerCase();
                const tags = (model.tags || []).map((t) => String(t).toLowerCase());

                if (preferredCategories.length && preferredCategories.includes(cat)) {
                    return true;
                }

                if (dt.includes('fortigate') && (name.includes('fortigate') || name.includes('fg'))) {
                    return true;
                }
                if (dt.includes('fortiswitch') && (name.includes('fortiswitch') || name.includes('fs'))) {
                    return true;
                }
                if (dt.includes('fortiap') && (name.includes('fortiap') || name === 'ap')) {
                    return true;
                }

                if (tags.some((t) => t.includes('fortinet')) || name.includes('fortinet')) {
                    return true;
                }
                return false;
            }

            const candidates = manifest.models.filter((m) => m.objPath);
            for (const m of candidates) {
                if (matches(m)) {
                    const objRel = m.objPath;
                    return '/lab_3d_models/' + objRel.replace(/^\/*/, '');
                }
            }
            return null;
        }


        async function loadDeviceModel(nodeData, position) {
            try {
                // Map device types to fallback 3D models (used only when no model is provided)
                const modelMap = {
                    'fortigate': '/static/3d-models/FortiGate.glb',
                    'fortiswitch': '/static/3d-models/FortiSwitch.glb',
                    'fortiap': '/static/3d-models/FortinetAP.glb',
                    'client': '/static/3d-models/generic_device.obj'
                };

                const typeKey = (nodeData.type || '').toLowerCase();

                const manifest = await loadLabModelManifest();
                const manifestModel = selectModelFromManifest(nodeData, manifest);

                // Candidate model paths, in order of preference:
                // 1) model from API (lab-format `model` field, usually /lab_3d_models/...)
                // 2) model chosen from lab_3d_models/manifest.json
                // 3) type-based fallback from modelMap
                // Load device models and create labels
                const labelGui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI('labels');
                for (let i = 0; i < nodes.length; i++) {
                    const nodeData = nodes[i];
                    await loadDeviceModel(nodeData);
                    // Create a label for the device
                    if (nodeData.mesh) {
                        const txt = new BABYLON.GUI.TextBlock();
                        txt.text = nodeData.name;
                        txt.color = 'white';
                        txt.fontSize = 12;
                        txt.background = 'rgba(0,0,0,0.5)';
                        const rect = new BABYLON.GUI.Rectangle();
                        rect.width = '120px';
                        rect.height = '30px';
                        rect.background = 'transparent';
                        rect.addControl(txt);
                        labelGui.addControl(rect);
                        rect.linkWithMesh(nodeData.mesh);
                        rect.linkOffsetY = -30;
                        nodeData.label = rect;
                        deviceLabels.push(rect);
                    }
                }
                // 4) generic client model
                const candidates = [];
                if (nodeData.model) {
                    candidates.push(nodeData.model);
                }
                if (manifestModel) {
                    candidates.push(manifestModel);
                }
                if (modelMap[typeKey]) {
                    candidates.push(modelMap[typeKey]);
                }
                candidates.push(modelMap['client']);

                for (let i = 0; i < candidates.length; i++) {
                    const candidate = candidates[i];
                    if (!candidate || typeof candidate !== 'string') continue;

                    const lastSlash = candidate.lastIndexOf('/');
                    const rootUrl = lastSlash >= 0 ? candidate.substring(0, lastSlash + 1) : "";
                    const filename = lastSlash >= 0 ? candidate.substring(lastSlash + 1) : candidate;

                    console.log('Attempting to load model:', candidate, 'root:', rootUrl, 'file:', filename);
                    try {
                        const result = await BABYLON.SceneLoader.ImportMeshAsync("", rootUrl, filename, scene);
                        if (result.meshes.length > 0) {
                            console.log('Successfully loaded model:', candidate);
                            const mesh = result.meshes[0];
                            mesh.position = position;

                            // Scale the model appropriately (VSS-derived GLTFs and OBJs are small)
                            mesh.scaling = new BABYLON.Vector3(1.0, 1.0, 1.0);

                            mesh.metadata = {
                                ...nodeData,
                                deviceType: nodeData.device_type || nodeData.type,
                                modelPath: candidate,
                                isRealisticModel: true
                            };
                            return mesh;
                        }
                    } catch (e) {
                        console.log('Failed to load model for', nodeData.name, 'from', candidate, e);
                        // Try next candidate
                    }
                }
            } catch (error) {
                console.log('Failed to load 3D model for', nodeData && nodeData.name, error);
            }
            console.log('No suitable model found for', nodeData.name, 'candidates:', candidates);
            return null;
        }

        function createDeviceBox(nodeData, position) {
            // Create device-specific box based on type
            let size = { width: 1.5, height: 1, depth: 0.5 };
            let color = new BABYLON.Color3(0.3, 0.6, 0.9);

            // Customize based on device type
            switch (nodeData.type?.toLowerCase()) {
                case 'fortigate':
                    size = { width: 2, height: 1.5, depth: 0.8 };
                    color = new BABYLON.Color3(0.8, 0.3, 0.3); // Red for firewall
                    break;
                case 'fortiswitch':
                    size = { width: 3, height: 0.5, depth: 1 };
                    color = new BABYLON.Color3(0.3, 0.8, 0.3); // Green for switch
                    break;
                case 'fortiap':
                    size = { width: 0.8, height: 0.3, depth: 0.8 };
                    color = new BABYLON.Color3(0.8, 0.8, 0.3); // Yellow for AP
                    break;
                case 'client':
                    size = { width: 1, height: 0.8, depth: 0.6 };
                    color = new BABYLON.Color3(0.6, 0.6, 0.6); // Gray for client
                    break;
            }

            const mesh = BABYLON.MeshBuilder.CreateBox(nodeData.id, size, scene);
            mesh.position = position;

            const material = new BABYLON.StandardMaterial(`mat_${ nodeData.id } `, scene);
            material.diffuseColor = color;
            material.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            mesh.material = material;

            mesh.metadata = {
                ...nodeData,
                deviceType: nodeData.device_type || nodeData.type
            };

            return mesh;
        }

        function createDeviceLabel(nodeData, mesh) {
            try {
                const nameText = nodeData.name || 'Device';
                const ipText = nodeData.ip || '';
                const macText = nodeData.mac || '';
                const vlanText = (nodeData.vlan !== undefined && nodeData.vlan !== null)
                    ? String(nodeData.vlan)
                    : '';
                const dtWidth = 256;
                const dtHeight = 112;
                const texture = new BABYLON.DynamicTexture(`${ nodeData.id } _label_tex`, { width: dtWidth, height: dtHeight }, scene, false);
                texture.hasAlpha = true;
                const font = "20px 'Segoe UI'";

                // High-contrast background for readability
                let y = 34;
                texture.drawText(nameText, null, y, font, "#ffffff", "rgba(10, 12, 30, 0.95)", true);
                if (ipText) {
                    y += 24;
                    texture.drawText(ipText, null, y, font, "#a8c5ff", null, true);
                }

                const detailParts = [];
                if (vlanText) {
                    detailParts.push(`VLAN: ${ vlanText } `);
                }
                if (macText) {
                    // Use full MAC address in label
                    detailParts.push(`MAC: ${ macText } `);
                }
                if (detailParts.length > 0) {
                    y += 24;
                    texture.drawText(detailParts.join('  ¬∑  '), null, y, font, "#d0d7ff", null, true);
                }

                const labelMat = new BABYLON.StandardMaterial(`${ nodeData.id } _label_mat`, scene);
                labelMat.diffuseTexture = texture;
                labelMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
                labelMat.backFaceCulling = false;

                // Slightly larger plane and position just below the icon, above the ground
                const labelPlane = BABYLON.MeshBuilder.CreatePlane(`${ nodeData.id } _label`, { width: 3.2, height: 1.1 }, scene);
                labelPlane.parent = mesh;
                labelPlane.position = new BABYLON.Vector3(0, 0.5, 0);
                labelPlane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
                labelPlane.material = labelMat;
                deviceLabels.push(labelPlane);
            } catch (e) {
                console.log('Failed to create label for', nodeData && nodeData.name, e);
            }
        }

        async function addSVGOverlay(nodeData, mesh) {
            try {
                // Map device types to realistic SVG files (fallbacks)
                const svgMap = {
                    'fortigate': '/realistic_device_svgs/FortiGate.svg',
                    'fortiswitch': '/realistic_device_svgs/FortiSwitch.svg',
                    'fortiap': '/realistic_device_svgs/FortiAP.svg',
                    'client': '/realistic_device_svgs/Laptop.svg'
                };

                const typeKey = (nodeData.type || '').toLowerCase();

                // Prefer icon_svg from the API (VSS‚ÜíSVG), fall back to type-based SVG
                const svgPath = nodeData.icon_svg || svgMap[typeKey] || svgMap['client'];

                // Create a small plane for 2D overlay
                const overlay = BABYLON.MeshBuilder.CreatePlane(`${ nodeData.id } _overlay`,
                    { width: 3, height: 2 }, scene);
                overlay.position = new BABYLON.Vector3(
                    mesh.position.x,
                    mesh.position.y + 2.5,
                    mesh.position.z
                );
                overlay.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

                // Create material with SVG texture
                const overlayMaterial = new BABYLON.StandardMaterial(`${ nodeData.id } _overlay_mat`, scene);

                // Try to load SVG as texture
                try {
                    const texture = new BABYLON.Texture(svgPath, scene);
                    overlayMaterial.diffuseTexture = texture;
                    overlayMaterial.emissiveColor = new BABYLON.Color3(0.8, 0.8, 0.8);
                    overlayMaterial.backFaceCulling = false;
                } catch (e) {
                    console.log(`Failed to load SVG texture for ${ nodeData.name }: `, e);
                    // Fallback to device-type color
                    overlayMaterial.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.9);
                    overlayMaterial.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                }

                overlay.material = overlayMaterial;

                // Parent overlay to mesh
                overlay.parent = mesh;

                // Track which SVG was actually used so we can display it in the UI
                if (!mesh.metadata) {
                    mesh.metadata = { ...nodeData };
                }
                mesh.metadata.iconSvgPath = svgPath;

            } catch (error) {
                console.log(`Failed to add SVG overlay for ${ nodeData.name }:`, error);
            }
        }

        function initUI() {
            document.getElementById('loadTopologyBtn').addEventListener('click', loadTopologyFromLab);

            document.getElementById('autoRotateBtn').addEventListener('click', () => {
                autoRotate = !autoRotate;
                document.getElementById('autoRotateBtn').classList.toggle('active', autoRotate);
            });

            document.getElementById('resetViewBtn').addEventListener('click', () => {
                if (camera) {
                    camera.alpha = 0;
                    camera.beta = Math.PI / 3;
                    camera.radius = 30;
                }
            });

            document.getElementById('labelsBtn').addEventListener('click', () => {
                labelsVisible = !labelsVisible;
                const btn = document.getElementById('labelsBtn');
                btn.classList.toggle('active', labelsVisible);
                deviceLabels.forEach(label => {
                    if (label) label.isVisible = labelsVisible;
                });
            });

            const exportDrawIOXmlBtn = document.getElementById('exportDrawIOXmlBtn');
            const exportDrawIO3DSceneBtn = document.getElementById('exportDrawIO3DSceneBtn');
            if (exportDrawIOXmlBtn) {
                exportDrawIOXmlBtn.addEventListener('click', exportDrawIOXml);
            }
            if (exportDrawIO3DSceneBtn) {
                exportDrawIO3DSceneBtn.addEventListener('click', exportDrawIO3DScene);
            }

            const sidebarToggle = document.getElementById('sidebarToggle');
            const leftSidebar = document.getElementById('leftSidebar');
            sidebarToggle.addEventListener('click', () => {
                leftSidebar.classList.toggle('open');
            });
        }


        async function exportDrawIOXml() {
            try {
                updateStatus('Exporting DrawIO XML...');
                showLoading();
                const resp = await fetch('/api/topology/drawio-xml', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ layout: 'hierarchical', group_by: 'type', show_details: true, color_code: true })
                });
                if (!resp.ok) {
                    const text = await resp.text();
                    throw new Error('HTTP ' + resp.status + ': ' + text);
                }
                const xmlText = await resp.text();
                const blob = new Blob([xmlText], { type: 'application/xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'fortinet_topology.drawio';
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                updateStatus('DrawIO XML exported');
            } catch (err) {
                console.error('Failed to export DrawIO XML:', err);
                showError(err.message || String(err));
                updateStatus('Error');
            } finally {
                hideLoading();
            }
        }


        async function exportDrawIO3DScene() {
            try {
                updateStatus('Exporting 3D scene JSON...');
                showLoading();
                const resp = await fetch('/api/topology/drawio-3d-scene', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ layout: 'hierarchical', group_by: 'type', show_details: true, color_code: true })
                });
                if (!resp.ok) {
                    const text = await resp.text();
                    throw new Error('HTTP ' + resp.status + ': ' + text);
                }
                const sceneData = await resp.json();
                const blob = new Blob([JSON.stringify(sceneData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'fortinet_scene.json';
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                updateStatus('3D scene JSON exported');
            } catch (err) {
                console.error('Failed to export 3D scene JSON:', err);
                showError(err.message || String(err));
                updateStatus('Error');
            } finally {
                hideLoading();
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            initBabylon();
            initUI();
            // Automatically load the lab topology on page load so the canvas is never blank
            loadTopologyFromLab();
        });
    </script>
</body>

</html>