<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="3D Network Topology Lab Viewer built with Babylon.js">
    <meta name="keywords" content="3D, Network, Topology, Lab, Viewer, Babylon.js, WebGL">
    <meta name="author" content="Your Name or Organization">
    <title>3D Network Topology Lab Viewer</title>
    <script src="/static/js/babylon.js"></script>
    <script src="/static/js/babylonjs.loaders.min.js"></script>
    <script src="/static/js/babylon.gui.min.js"></script>
    <style>
        /* Reuse the same layout and styling as babylon_topology.html for consistency */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0e1116 0%, #1a1f2e 100%);
            color: #ffffff;
            overflow: hidden;
            height: 100vh;
            display: grid;
            grid-template-rows: 60px 1fr 40px;
            grid-template-columns: 0 1fr 0;
            grid-template-areas:
                "header header header"
                "sidebar main details"
                "status status status";
        }

        .top-toolbar {
            grid-area: header;
            background: rgba(30, 35, 50, 0.95);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(88, 166, 255, 0.3);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 15px;
            z-index: 1000;
        }

        .toolbar-group {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 0 15px;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
        }

        .toolbar-group:last-child {
            border-right: none;
            margin-left: auto;
        }

        .toolbar-title {
            font-size: 18px;
            font-weight: 600;
            color: #58a6ff;
            margin-right: 20px;
        }

        .left-sidebar {
            grid-area: sidebar;
            background: rgba(30, 35, 50, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-right: 1px solid rgba(88, 166, 255, 0.3);
            width: 280px;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            overflow-y: auto;
            z-index: 999;
        }

        .left-sidebar.open {
            transform: translateX(0);
        }

        .sidebar-toggle {
            position: absolute;
            left: 10px;
            top: 70px;
            background: rgba(88, 166, 255, 0.2);
            border: 1px solid rgba(88, 166, 255, 0.4);
            color: #58a6ff;
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 1001;
            transition: all 0.3s ease;
        }

        .sidebar-toggle:hover {
            background: rgba(88, 166, 255, 0.3);
            transform: scale(1.05);
        }

        .main-canvas {
            grid-area: main;
            position: relative;
            width: 100%;
            height: 100%;
        }

        #renderCanvas {
            width: 100%;
            height: 100%;
            display: block;
            cursor: grab;
        }

        #renderCanvas:active {
            cursor: grabbing;
        }

        .details-panel {
            grid-area: details;
            background: rgba(30, 35, 50, 0.9);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-left: 1px solid rgba(88, 166, 255, 0.3);
            width: 350px;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            overflow-y: auto;
            z-index: 999;
        }

        .details-panel.open {
            transform: translateX(0);
        }

        .status-bar {
            grid-area: status;
            background: rgba(20, 25, 40, 0.95);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            border-top: 1px solid rgba(88, 166, 255, 0.3);
            display: flex;
            align-items: center;
            padding: 0 20px;
            gap: 30px;
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .status-label {
            color: rgba(255, 255, 255, 0.5);
        }

        .status-value {
            color: #58a6ff;
            font-weight: 500;
        }

        .control-group {
            margin: 20px 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .control-group h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #58a6ff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        button {
            background: linear-gradient(135deg, rgba(88, 166, 255, 0.2), rgba(88, 166, 255, 0.1));
            border: 1px solid rgba(88, 166, 255, 0.4);
            color: #ffffff;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        button:hover {
            background: linear-gradient(135deg, rgba(88, 166, 255, 0.3), rgba(88, 166, 255, 0.2));
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(88, 166, 255, 0.2);
        }

        button:active {
            transform: translateY(0);
        }

        button.active {
            background: linear-gradient(135deg, rgba(88, 166, 255, 0.4), rgba(88, 166, 255, 0.3));
            border-color: #58a6ff;
        }

        .data-source-buttons {
            display: flex;
            gap: 5px;
            margin-top: 10px;
        }

        .data-source-buttons button {
            flex: 1;
            font-size: 12px;
            padding: 6px 8px;
        }

        #deviceInfo {
            padding: 20px;
        }

        #deviceInfo.hidden {
            display: none;
        }

        .device-details {
            font-size: 13px;
            line-height: 1.5;
        }

        .device-details h4 {
            color: #58a6ff;
            margin: 0 0 15px 0;
            font-size: 16px;
            border-bottom: 1px solid rgba(88, 166, 255, 0.3);
            padding-bottom: 10px;
        }

        .label {
            color: rgba(255, 255, 255, 0.6);
            font-weight: 500;
        }

        .value {
            color: #ffffff;
            margin-left: 5px;
        }

        #loading,
        #error {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(30, 35, 50, 0.95);
            padding: 30px;
            border-radius: 12px;
            border: 1px solid rgba(88, 166, 255, 0.3);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            z-index: 2000;
        }

        .hidden {
            display: none;
        }

        .device-tooltip {
            position: fixed;
            padding: 8px 12px;
            background: rgba(15, 20, 35, 0.95);
            border-radius: 6px;
            border: 1px solid rgba(88, 166, 255, 0.8);
            color: #ffffff;
            font-size: 12px;
            pointer-events: none;
            transform: translate(-50%, -120%);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.4);
            z-index: 2500;
            white-space: nowrap;
        }

        @media (max-width: 1200px) {
            .details-panel {
                width: 300px;
            }
        }

        @media (max-width: 768px) {
            body {
                grid-template-columns: 1fr;
                grid-template-areas:
                    "header header"
                    "main main"
                    "status status";
            }

            .left-sidebar,
            .details-panel {
                position: fixed;
                top: 60px;
                height: calc(100vh - 100px);
                box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            }

            .details-panel {
                right: 0;
                width: 100%;
                max-width: 350px;
            }
        }
    </style>
</head>

<body>
    <header class="top-toolbar">
        <div class="toolbar-title">üß™ 3D Network Topology Lab</div>
        <div class="toolbar-group">
            <button id="loadTopologyBtn">üåê Load Lab Topology</button>
            <button id="resetViewBtn">üì∑ Reset View</button>
        </div>
        <div class="toolbar-group">
            <button id="autoRotateBtn">üîÑ Auto-Rotate</button>
            <button id="labelsBtn">üè∑Ô∏è Labels</button>
        </div>
        <div class="toolbar-group">
            <button id="exportDrawIOXmlBtn">üßæ Export DrawIO XML</button>
            <button id="exportDrawIO3DSceneBtn">üéÆ Export 3D JSON</button>
        </div>
        <div class="toolbar-group">
            <span class="status-label">Status:</span>
            <span id="statusText" class="status-value">Ready</span>
        </div>
    </header>

    <button class="sidebar-toggle" id="sidebarToggle">‚ò∞</button>

    <aside class="left-sidebar" id="leftSidebar">
        <div class="control-group">
            <h3>Data Source</h3>
            <p style="font-size: 12px; color: rgba(255,255,255,0.7);">
                Using <code>/api/topology/babylon-lab-format</code> from Enhanced Network API.
            </p>
        </div>
    </aside>

    <main class="main-canvas">
        <canvas id="renderCanvas"></canvas>

        <!-- Debug Log -->
        <div id="debugLog"
            style="position: absolute; top: 10px; left: 10px; background: rgba(0,0,0,0.8); color: lime; font-family: monospace; padding: 10px; max-height: 300px; overflow-y: auto; z-index: 3000; pointer-events: none; width: 400px;">
            <div>Debug Log:</div>
        </div>

        <!-- Loading Overlay -->
        <div id="loading" class="hidden">
            <div>üîÑ Loading topology...</div>
        </div>

        <!-- Error Overlay -->
        <div id="error" class="hidden">
            <div>‚ùå <span id="errorMessage">Error loading topology</span></div>
        </div>
        <!-- Hover tooltip for device info -->
        <div id="deviceTooltip" class="device-tooltip hidden"></div>
    </main>

    <aside class="details-panel" id="deviceInfo">
        <div id="deviceDetails">
            <div class="device-details">
                <h4>üìã Device Details</h4>
                <p>Select a device to view details...</p>
            </div>
        </div>
    </aside>

    <footer class="status-bar">
        <div class="status-item">
            <span class="status-label">üéØ FPS:</span>
            <span id="fpsCounter" class="status-value">60</span>
        </div>
        <div class="status-item">
            <span class="status-label">üì¶ Objects:</span>
            <span id="objectCounter" class="status-value">0</span>
        </div>
        <div class="status-item">
            <span class="status-label">üîó Devices:</span>
            <span id="deviceCounter" class="status-value">0</span>
        </div>
    </footer>

    <script>
        let engine, scene, camera;
        let devices = [];
        let links = [];
        let nodes = []; // Global nodes array for filtering
        let autoRotate = false;
        let tooltipEl = null;
        let labelsVisible = true;
        let deviceLabels = [];

        function showLoading() {
            document.getElementById('loading').classList.remove('hidden');
            document.getElementById('error').classList.add('hidden');
        }

        function hideLoading() {
            document.getElementById('loading').classList.add('hidden');
        }

        function showError(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('error').classList.remove('hidden');
            document.getElementById('loading').classList.add('hidden');
        }

        function updateStatus(status) {
            document.getElementById('statusText').textContent = status;
        }

        function updateStats() {
            if (!scene || !engine) return;
            const fpsCounter = document.getElementById('fpsCounter');
            const objectCounter = document.getElementById('objectCounter');
            const deviceCounter = document.getElementById('deviceCounter');
            if (fpsCounter) fpsCounter.textContent = Math.round(engine.getFps());
            if (objectCounter) objectCounter.textContent = scene.meshes.length;
            if (deviceCounter) deviceCounter.textContent = devices.length;
        }


        function fitCameraToNodes(nodes) {
            if (!camera || !nodes || !nodes.length) return;

            let minX = Infinity, maxX = -Infinity;
            let minZ = Infinity, maxZ = -Infinity;

            nodes.forEach((n) => {
                if (!n.position) return;
                const x = typeof n.position.x === 'number' ? n.position.x : 0;
                const z = typeof n.position.z === 'number' ? n.position.z : 0;
                if (x < minX) minX = x;
                if (x > maxX) maxX = x;
                if (z < minZ) minZ = z;
                if (z > maxZ) maxZ = z;
            });

            if (!isFinite(minX) || !isFinite(maxX) || !isFinite(minZ) || !isFinite(maxZ)) {
                return;
            }
            // Compute center and extent
            const centerX = (minX + maxX) / 2;
            const centerZ = (minZ + maxZ) / 2;
            const extent = Math.max(maxX - minX, maxZ - minZ, 10);
            const radius = extent * 2.5;

            camera.target = new BABYLON.Vector3(centerX, 0, centerZ);
            camera.radius = radius;
            camera.beta = Math.PI / 3; // Keep a comfortable tilt
        }

        function showTooltip(deviceData, clientX, clientY) {
            if (!tooltipEl) return;
            const name = deviceData.name || 'Unknown Device';
            const ip = deviceData.ip || 'N/A';
            const type = deviceData.deviceType || deviceData.type || '';
            const mac = deviceData.mac || '';
            const vendor = deviceData.vendor || deviceData.device_vendor || '';
            const vlan = deviceData.vlan || '';

            let html = `<strong>${name}</strong>`;
            if (ip) {
                html += `<br>IP: ${ip}`;
            }
            if (type) {
                html += `<br>Type: ${type}`;
            }
            if (vendor) {
                html += `<br>Vendor: ${vendor}`;
            }
            if (mac) {
                html += `<br>MAC: ${mac}`;
            }
            if (vlan) {
                html += `<br>VLAN: ${vlan}`;
            }
            tooltipEl.innerHTML = html;
            tooltipEl.style.left = clientX + 'px';
            tooltipEl.style.top = clientY + 'px';
            tooltipEl.classList.remove('hidden');
        }

        function hideTooltip() {
            if (!tooltipEl) return;
            tooltipEl.classList.add('hidden');
        }

        function logDebug(msg) {
            console.log(msg);
            const log = document.getElementById('debugLog');
            if (log) {
                const line = document.createElement('div');
                line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
                log.appendChild(line);
                log.scrollTop = log.scrollHeight;
            }
        }

        // Initialize Babylon.js
        function initBabylon() {
            try {
                logDebug('üéÆ Initializing Babylon.js...');

                const canvas = document.getElementById('renderCanvas');
                if (!canvas) {
                    throw new Error('Canvas element not found');
                }

                logDebug('‚úÖ Canvas found');

                // Check for WebGL support explicitly
                const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                if (!gl) {
                    throw new Error('WebGL not supported');
                }

                // Set canvas dimensions
                canvas.width = canvas.parentElement.clientWidth;
                canvas.height = canvas.parentElement.clientHeight;

                // Create engine
                engine = new BABYLON.Engine(canvas, true);
                window.engine = engine;
                if (!engine) {
                    throw new Error('Failed to create Babylon.js engine');
                }

                logDebug('‚úÖ Babylon.js engine created');

                scene = new BABYLON.Scene(engine);
                window.scene = scene;
                if (!scene) {
                    throw new Error('Failed to create Babylon.js scene');
                }

                logDebug('‚úÖ Babylon.js scene created');

                // Set background
                const manager = new BABYLON.GUI.GUI3DManager(scene);

                // 3D GUI ‚Äì Topology Control Panel (floating in the scene)
                // Position it to the LEFT side of the scene, visible from default camera angle
                // ------------------------------------------------------------
                const topoPanel = new BABYLON.GUI.StackPanel3D();
                topoPanel.isVertical = true;
                topoPanel.margin = 0.05;
                manager.addControl(topoPanel);
                topoPanel.position = new BABYLON.Vector3(-6, 3, 0); // Left side, elevated
                topoPanel.scaling = new BABYLON.Vector3(2, 2, 2); // Make it bigger

                logDebug('‚úÖ 3D GUI panel created');

                // Helper to create a 3D button
                function make3DButton(name, label, onClick) {
                    const btn = new BABYLON.GUI.HolographicButton(name);
                    btn.text = label;
                    btn.onPointerUpObservable.add(onClick);
                    return btn;
                }

                // Reset View button
                topoPanel.addControl(make3DButton('reset3d', 'üì∑ Reset View', () => {
                    if (camera) {
                        camera.alpha = 0;
                        camera.beta = Math.PI / 3;
                        camera.radius = 30;
                        logDebug('üîÅ Camera reset');
                    }
                }));

                // Auto‚Äërotate toggle
                topoPanel.addControl(make3DButton('autoRotate', 'üîÑ Auto‚ÄëRotate', () => {
                    autoRotate = !autoRotate;
                    logDebug(`üîÑ Auto‚Äërotate ${autoRotate ? 'ON' : 'OFF'}`);
                }));

                // Labels toggle button (simplified - RadioGroup/CheckboxGroup don't exist in 3D GUI)
                topoPanel.addControl(make3DButton('toggleLabels', 'üè∑Ô∏è Toggle Labels', () => {
                    labelsVisible = !labelsVisible;
                    deviceLabels.forEach(l => l.isVisible = labelsVisible);
                    logDebug(`üè∑Ô∏è Labels ${labelsVisible ? 'shown' : 'hidden'}`);
                }));

                // Device filters as buttons (simplified until we implement proper 3D GUI controls)
                topoPanel.addControl(make3DButton('filterAll', 'üåê Show All', () => filterDevices('all')));
                topoPanel.addControl(make3DButton('filterSwitch', 'üîå Switches', () => filterDevices('switch')));
                topoPanel.addControl(make3DButton('filterRouter', 'üåê Routers', () => filterDevices('router')));

                logDebug('‚úÖ 3D GUI buttons added');

                /* COMMENTED OUT - These classes don't exist in Babylon.js 3D GUI and cause crashes
                // Device‚Äëtype filter (radio group)
                const typeGroup = new BABYLON.GUI.RadioGroup('typeFilter');
                typeGroup.addRadio('All', () => filterDevices('all'), true);
                typeGroup.addRadio('Switches', () => filterDevices('switch'));
                typeGroup.addRadio('Routers', () => filterDevices('router'));
                typeGroup.addRadio('Servers', () => filterDevices('server'));
                const typePanel = new BABYLON.GUI.StackPanel3D();
                typePanel.isVertical = true;
                const typeHeader = new BABYLON.GUI.TextBlock();
                typeHeader.text = 'Device Type';
                typeHeader.color = 'white';
                typePanel.addControl(typeHeader);
                typePanel.addControl(typeGroup);
                topoPanel.addControl(typePanel);

                // Vendor filter (checkbox group)
                const vendorGroup = new BABYLON.GUI.CheckboxGroup('Vendor');
                vendorGroup.addCheckbox('Cisco', v => filterVendor('cisco', v));
                vendorGroup.addCheckbox('Fortinet', v => filterVendor('fortinet', v));
                vendorGroup.addCheckbox('Juniper', v => filterVendor('juniper', v));
                const vendorPanel = new BABYLON.GUI.StackPanel3D();
                vendorPanel.isVertical = true;
                const vendorHeader = new BABYLON.GUI.TextBlock();
                vendorHeader.text = 'Vendor';
                vendorHeader.color = 'white';
                vendorPanel.addControl(vendorHeader);
                vendorPanel.addControl(vendorGroup);
                topoPanel.addControl(vendorPanel);
                */

                // ------------------------------------------------------------
                // Device Details - Using HTML Side Panel
                // (HolographicSlate is incompatible with GUI3DManager)
                // ------------------------------------------------------------
                function showDeviceInfo(node) {
                    if (!node) return;
                    // Use the existing HTML panel on the right side
                    showDeviceInfoHTML(node);
                    logDebug(`üìã Showing details for: ${node.name}`);
                }

                // ------------------------------------------------------------
                // Filtering helper functions (device type & vendor)
                // ------------------------------------------------------------
                function filterDevices(mode) {
                    // mode: 'all' | 'switch' | 'router' | 'server'
                    nodes.forEach(n => {
                        if (!n.mesh) return;
                        const visible = (mode === 'all') || (n.type && n.type.toLowerCase() === mode);
                        n.mesh.setEnabled(visible);
                        if (n.label) n.label.isVisible = visible && labelsVisible;
                    });
                    logDebug(`üîé Device filter: ${mode}`);
                }
                function filterVendor(vendorKey, isChecked) {
                    nodes.forEach(n => {
                        if (!n.mesh) return;
                        const match = n.vendor && n.vendor.toLowerCase().includes(vendorKey);
                        const visible = isChecked ? match : !match;
                        // Combine with current type filter ‚Äì we only toggle the vendor flag
                        if (visible) n.mesh.setEnabled(true);
                        else n.mesh.setEnabled(false);
                        if (n.label) n.label.isVisible = visible && labelsVisible;
                    });
                    logDebug(`üîé Vendor ${vendorKey} ${isChecked ? 'ON' : 'OFF'}`);
                }
                scene.clearColor = new BABYLON.Color4(0.05, 0.05, 0.1, 1.0);

                // Create camera
                camera = new BABYLON.ArcRotateCamera('camera', 0, Math.PI / 3, 30, BABYLON.Vector3.Zero(), scene);
                window.camera = camera;
                camera.attachControl(canvas, true);
                camera.wheelPrecision = 50;
                camera.lowerRadiusLimit = 5;
                camera.upperRadiusLimit = 100;

                logDebug('‚úÖ Camera created');

                // Add BRIGHT lights for visibility of textured models
                const hemisphericLight = new BABYLON.HemisphericLight('hemisphericLight', new BABYLON.Vector3(0, 1, 0), scene);
                hemisphericLight.intensity = 1.5; // Very bright ambient

                const dirLight = new BABYLON.DirectionalLight('dirLight', new BABYLON.Vector3(-1, -2, -1), scene);
                dirLight.position = new BABYLON.Vector3(20, 40, 20);
                dirLight.intensity = 1.2; // Increased from 0.6

                // Add point light for additional illumination
                const pointLight = new BABYLON.PointLight('pointLight', new BABYLON.Vector3(0, 15, 0), scene);
                pointLight.intensity = 0.8;

                const shadowGenerator = new BABYLON.ShadowGenerator(1024, dirLight);
                shadowGenerator.useExponentialShadowMap = true;

                // Create ground BEFORE referencing it
                const ground = BABYLON.MeshBuilder.CreateGround('ground', { width: 80, height: 80 }, scene);
                const groundMat = new BABYLON.StandardMaterial('groundMat', scene);
                groundMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.15);
                groundMat.specularColor = new BABYLON.Color3(0, 0, 0);
                ground.material = groundMat;
                ground.receiveShadows = true;

                logDebug('‚úÖ Lighting configured (bright for textured models)');

                // Create grid
                const gridMaterial = new BABYLON.StandardMaterial('gridMaterial', scene);
                gridMaterial.wireframe = true;
                gridMaterial.diffuseColor = new BABYLON.Color3(0.2, 0.3, 0.4);
                gridMaterial.emissiveColor = new BABYLON.Color3(0.1, 0.15, 0.2);

                const grid = BABYLON.MeshBuilder.CreateGround('grid', { width: 40, height: 40, subdivisions: 20 }, scene);
                grid.material = gridMaterial;
                grid.position.y = 0.01;

                logDebug('‚úÖ Ground and grid created');

                // Handle pointer events (selection & hover)
                scene.onPointerObservable.add((pointerInfo) => {
                    if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERPICK) {
                        if (pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh) {
                            const pickedMesh = pointerInfo.pickInfo.pickedMesh;

                            // Highlight selection
                            if (pickedMesh.metadata && !pickedMesh.parent) {
                                // Remove previous highlights
                                scene.meshes.forEach(m => { if (m.highlightLayer) m.highlightLayer.removeMesh(m); });
                                // Add highlight layer if not exists
                                if (!scene.highlightLayer) {
                                    scene.highlightLayer = new BABYLON.HighlightLayer('hl1', scene);
                                }
                                scene.highlightLayer.addMesh(pickedMesh, BABYLON.Color3.Yellow());
                                // Show device details in the holographic slate
                                showDeviceInfo(pickedMesh.metadata);
                                logDebug('üîç Device selected: ' + pickedMesh.metadata.name);
                            }
                        }
                    } else if (pointerInfo.type === BABYLON.PointerEventTypes.POINTERMOVE) {
                        // Hover tooltip
                        if (pointerInfo.pickInfo && pointerInfo.pickInfo.hit && pointerInfo.pickInfo.pickedMesh) {
                            const hovered = pointerInfo.pickInfo.pickedMesh;
                            if (hovered.metadata) {
                                showTooltip(hovered.metadata, pointerInfo.event.clientX, pointerInfo.event.clientY);
                            }
                        } else {
                            hideTooltip();
                        }
                    }
                });

                // Start render loop
                engine.runRenderLoop(() => {
                    try {
                        if (autoRotate && camera) {
                            camera.alpha += 0.005;
                        }
                        if (scene) {
                            scene.render();
                        }
                        updateStats();
                    } catch (error) {
                        console.error('‚ùå Render loop error:', error);
                    }
                });

                logDebug('‚úÖ Render loop started');

                // Handle window resize
                window.addEventListener('resize', () => {
                    if (engine) {
                        engine.resize();
                    }
                });

                window.babylonReady = true;

            } catch (error) {
                console.error('‚ùå Failed to initialize Babylon.js:', error);
                logDebug('‚ùå Init Error: ' + error.message);

                // Show user-friendly error with 2D fallback option
                const errorDiv = document.getElementById('error');
                const errorMessage = document.getElementById('errorMessage');
                const loading = document.getElementById('loading');

                if (loading) loading.classList.add('hidden');
                if (errorDiv) {
                    errorDiv.classList.remove('hidden');
                    errorDiv.innerHTML = `
                    < div style = "text-align: center;" >
                            <h3 style="color: #ff5555; margin-bottom: 10px;">‚ùå 3D Engine Error</h3>
                            <p>${error.message}</p>
                            <p style="margin-top: 15px; font-size: 14px; color: #aaa;">
                                Your browser or environment does not support WebGL, which is required for 3D visualization.
                            </p>
                            <a href="/static/2d_topology_enhanced.html" style="display: inline-block; margin-top: 20px; padding: 10px 20px; background: #58a6ff; color: white; text-decoration: none; border-radius: 5px; font-weight: bold;">
                                ‚û°Ô∏è Switch to 2D View
                            </a>
                        </div >
                    `;
                }
            }
        }

        // UI Functions
        function showLoading() {
            const loading = document.getElementById('loading');
            const error = document.getElementById('error');
            if (loading) loading.classList.remove('hidden');
            if (error) error.classList.add('hidden');
        }

        function hideLoading() {
            const loading = document.getElementById('loading');
            if (loading) loading.classList.add('hidden');
        }

        function showError(message) {
            const errorMessage = document.getElementById('errorMessage');
            const error = document.getElementById('error');
            const loading = document.getElementById('loading');
            if (errorMessage) errorMessage.textContent = message;
            if (error) error.classList.remove('hidden');
            if (loading) loading.classList.add('hidden');
            logDebug('‚ùå Error: ' + message);
        }

        function hideError() {
            document.getElementById('error').classList.add('hidden');
        }

        function updateStatus(status) {
            const statusText = document.getElementById('statusText');
            const sceneStatus = document.getElementById('sceneStatus');
            if (statusText) statusText.textContent = status;
            if (sceneStatus) sceneStatus.textContent = status;
            logDebug('Status: ' + status);
        }

        function updateStats() {
            if (scene) {
                const fpsCounter = document.getElementById('fpsCounter');
                const objectCounter = document.getElementById('objectCounter');
                const deviceCounter = document.getElementById('deviceCounter');

                if (fpsCounter) fpsCounter.textContent = Math.round(engine.getFps());
                if (objectCounter) objectCounter.textContent = scene.meshes.length;
                if (deviceCounter) deviceCounter.textContent = devices.length;
            }
        }

        function showDeviceInfoHTML(deviceData) {
            const deviceInfo = document.getElementById('deviceInfo');
            const deviceDetails = document.getElementById('deviceDetails');

            if (!deviceInfo || !deviceDetails) return;

            deviceInfo.classList.add('open');

            let detailsHTML = `< div class="device-details" > `;
            detailsHTML += `< h4 >üìã ${deviceData.name || 'Unknown Device'}</h4 > `;

            detailsHTML += `< div style = "margin-bottom: 15px;" > `;
            detailsHTML += `< h5 > Device Information</h5 > `;
            detailsHTML += `< div ><span class="label">Type:</span> <span class="value">${deviceData.deviceType || deviceData.type || 'Unknown'}</span></div > `;
            detailsHTML += `< div ><span class="label">Vendor:</span> <span class="value">${deviceData.deviceVendor || 'Unknown'}</span></div > `;
            detailsHTML += `< div ><span class="label">Model:</span> <span class="value">${deviceData.model || 'Unknown'}</span></div > `;
            detailsHTML += `< div ><span class="label">IP:</span> <span class="value">${deviceData.ip || 'N/A'}</span></div > `;
            detailsHTML += `< div ><span class="label">Status:</span> <span class="value">${deviceData.status || 'Unknown'}</span></div > `;
            if (deviceData.mac) detailsHTML += `< div ><span class="label">MAC:</span> <span class="value">${deviceData.mac}</span></div > `;
            detailsHTML += `</div > `;

            // Show enhanced device information if available
            if (deviceData.deviceModel || deviceData.device_confidence) {
                detailsHTML += `< div style = "margin-bottom: 15px;" > `;
                detailsHTML += `< h5 > Device Recognition</h5 > `;
                if (deviceData.deviceModel) {
                    detailsHTML += `< div ><span class="label">3D Model:</span> <span class="value">${deviceData.deviceModel}</span></div > `;
                }
                if (deviceData.device_confidence) {
                    detailsHTML += `< div ><span class="label">Match Confidence:</span> <span class="value">${deviceData.device_confidence}</span></div > `;
                }
                if (deviceData.pos_system) {
                    detailsHTML += `< div ><span class="label">POS System:</span> <span class="value">${deviceData.pos_system}</span></div > `;
                }
                detailsHTML += `</div > `;
            }

            if (deviceData.health) {
                detailsHTML += `< div style = "margin-bottom: 15px;" > `;
                detailsHTML += `< h5 > Health & Performance</h5 > `;
                detailsHTML += `< div ><span class="label">Health:</span> <span class="value">${deviceData.health}</span></div > `;
                if (deviceData.cpu) detailsHTML += `< div ><span class="label">CPU:</span> <span class="value">${deviceData.cpu}</span></div > `;
                if (deviceData.memory) detailsHTML += `< div ><span class="label">Memory:</span> <span class="value">${deviceData.memory}</span></div > `;
                detailsHTML += `</div > `;
            }

            detailsHTML += `</div > `;
            deviceDetails.innerHTML = detailsHTML;
        }

        async function loadTopologyFromLab() {
            updateStatus('Loading...');
            showLoading();
            try {
                logDebug('üì° Fetching topology data...');
                const resp = await fetch('/api/topology/babylon-lab-format');
                if (!resp.ok) {
                    const text = await resp.text();
                    throw new Error('HTTP ' + resp.status + ': ' + text);
                }
                const lab = await resp.json();
                logDebug('‚úÖ Topology data received. Nodes: ' + (lab.models ? lab.models.length : 0));

                const models = lab.models || [];
                const connections = lab.connections || [];

                const nodes = models.map(function (m, idx) {
                    return {
                        id: m.id || ('node-' + idx),
                        name: m.name,
                        type: m.type,
                        device_type: m.type,
                        device_vendor: m.vendor,
                        vendor: m.vendor,
                        model: m.model,
                        icon_svg: m.icon_svg,
                        ip: m.ip,
                        mac: m.mac,
                        vlan: m.vlan,
                        status: m.status || 'online',
                        position: m.position || null,
                        // placeholder for mesh reference
                        mesh: null,
                        // placeholder for label GUI
                        label: null
                    };
                });

                const links = connections.map(function (c, idx) {
                    return {
                        id: c.id || ('link-' + idx),
                        from: c.from,
                        to: c.to,
                        status: c.status,
                        protocol: c.protocol,
                        bandwidth: c.bandwidth,
                        vlan: c.vlan
                    };
                });

                await renderTopology({ nodes: nodes, links: links });
                // Center and zoom camera so all nodes are comfortably in view
                fitCameraToNodes(nodes);
                updateStatus('Loaded');
                logDebug('‚úÖ Topology loaded successfully');
            } catch (err) {
                console.error('Failed to load lab topology:', err);
                showError(err.message || String(err));
                updateStatus('Error');
            } finally {
                hideLoading();
            }
        }

        // Network Tree Layout - Matches the specific Fortinet topology diagram
        // Layout: Internet (top) ‚Üí Fortigate (center) ‚Üí FortiSwitch (left) / Wireless AP (right) ‚Üí End Devices
        function calculateNetworkTreeLayout(nodes, links) {
            const nodeMap = {};
            nodes.forEach(n => nodeMap[n.id] = n);
            
            const spacing = {
                vertical: 8.0,
                horizontal: 6.0,
                device: 4.0
            };
            
            // Identify devices by type
            const internetNodes = [];
            const fortigateNodes = [];
            const switchNodes = [];
            const apNodes = [];
            const wiredClients = [];
            const wirelessClients = [];
            
            nodes.forEach(node => {
                const type = (node.type || node.role || '').toLowerCase();
                const connectionType = (node.connection_type || '').toLowerCase();
                
                if (type.includes('internet') || type.includes('wan')) {
                    internetNodes.push(node.id);
                } else if (type.includes('fortigate') || type.includes('firewall') || type.includes('gateway')) {
                    fortigateNodes.push(node.id);
                } else if (type.includes('fortiswitch') || (type.includes('switch') && type.includes('forti'))) {
                    switchNodes.push(node.id);
                } else if (type.includes('fortiap') || type.includes('access_point') || type.includes('ap') || type.includes('wireless')) {
                    apNodes.push(node.id);
                } else if (connectionType === 'wifi' || type.includes('wireless') || node.ssid) {
                    wirelessClients.push(node.id);
                } else if (connectionType === 'ethernet' || type.includes('wired') || type.includes('client') || type.includes('endpoint')) {
                    wiredClients.push(node.id);
                }
            });
            
            // Build parent-child relationships
            const parentByChild = {};
            links.forEach(link => {
                const source = link.from || link.source;
                const target = link.to || link.target;
                if (!source || !target) return;
                
                const sourceType = ((nodeMap[source] || {}).type || '').toLowerCase();
                const targetType = ((nodeMap[target] || {}).type || '').toLowerCase();
                
                // Internet ‚Üí Fortigate
                if (sourceType.includes('internet') && targetType.includes('fortigate')) {
                    parentByChild[target] = source;
                } else if (targetType.includes('internet') && sourceType.includes('fortigate')) {
                    parentByChild[source] = target;
                }
                // Fortigate ‚Üí Switch/AP
                else if (sourceType.includes('fortigate') && (targetType.includes('switch') || targetType.includes('ap'))) {
                    parentByChild[target] = source;
                } else if (targetType.includes('fortigate') && (sourceType.includes('switch') || sourceType.includes('ap'))) {
                    parentByChild[source] = target;
                }
                // Switch/AP ‚Üí Clients
                else if (sourceType.includes('switch') && (targetType.includes('client') || targetType.includes('endpoint'))) {
                    parentByChild[target] = source;
                } else if (targetType.includes('switch') && (sourceType.includes('client') || sourceType.includes('endpoint'))) {
                    parentByChild[source] = target;
                } else if (sourceType.includes('ap') && (targetType.includes('client') || targetType.includes('endpoint'))) {
                    parentByChild[target] = source;
                } else if (targetType.includes('ap') && (sourceType.includes('client') || sourceType.includes('endpoint'))) {
                    parentByChild[source] = target;
                }
            });
            
            // Calculate positions
            const positions = {};
            
            // Layer 1: Internet (top center)
            internetNodes.forEach(nodeId => {
                positions[nodeId] = { x: 0, y: spacing.vertical * 3, z: 0 };
            });
            
            // Layer 2: Fortigate (center, below Internet)
            fortigateNodes.forEach(nodeId => {
                positions[nodeId] = { x: 0, y: spacing.vertical * 2, z: 0 };
            });
            
            // Layer 3: FortiSwitch (left) and Wireless AP (right)
            const xLeft = -spacing.horizontal;
            const xRight = spacing.horizontal;
            
            switchNodes.forEach((nodeId, i) => {
                positions[nodeId] = { x: xLeft, y: spacing.vertical, z: 0 };
            });
            
            apNodes.forEach((nodeId, i) => {
                positions[nodeId] = { x: xRight, y: spacing.vertical, z: 0 };
            });
            
            // Layer 4: End devices (below their parent)
            wiredClients.forEach((nodeId, i) => {
                const parent = parentByChild[nodeId];
                const xPos = xLeft + (i - wiredClients.length / 2) * spacing.device;
                positions[nodeId] = { x: xPos, y: 0, z: 0 };
            });
            
            wirelessClients.forEach((nodeId, i) => {
                const parent = parentByChild[nodeId];
                const xPos = xRight + (i - wirelessClients.length / 2) * spacing.device;
                positions[nodeId] = { x: xPos, y: 0, z: 0 };
            });
            
            // Apply positions to nodes
            nodes.forEach(node => {
                if (positions[node.id]) {
                    node.calculatedPosition = positions[node.id];
                } else {
                    node.calculatedPosition = { x: 0, y: 0, z: 0 };
                }
            });
            
            return nodes;
        }
        
        // Legacy hierarchical layout (kept for compatibility)
        function calculateHierarchicalLayout(nodes, links) {
            return calculateNetworkTreeLayout(nodes, links);
        }

        async function renderTopology(data) {
            // Clear existing devices and links
            devices.forEach(d => d.dispose && d.dispose());
            devices = [];
            links.forEach(l => l.dispose && l.dispose());
            links = [];
            deviceLabels = [];
            nodes = []; // Clear global nodes array

            // Apply hierarchical auto-layout
            const layoutNodes = calculateHierarchicalLayout(data.nodes, data.links);

            // Render devices with hierarchical positioning
            for (let index = 0; index < layoutNodes.length; index++) {
                const nodeData = layoutNodes[index];
                const calcPos = nodeData.calculatedPosition;
                const position = new BABYLON.Vector3(calcPos.x, calcPos.y, calcPos.z);

                // Try to load actual 3D model first
                let mesh = await loadDeviceModel(nodeData, position);

                // Fallback to device-specific box if model loading fails
                if (!mesh) {
                    console.log('Falling back to box for', nodeData.name);
                    mesh = createDeviceBox(nodeData, position);
                }

                // Ensure mesh has proper metadata
                if (!mesh.metadata) {
                    mesh.metadata = { ...nodeData };
                }
                mesh.metadata.mesh = mesh; // Add mesh reference for GUI

                // Add 2D SVG overlay/sprite
                await addSVGOverlay(nodeData, mesh);

                // Add label with device name and IP under the icon
                createDeviceLabel(nodeData, mesh);

                // Build nodes array entry for filtering
                const nodeEntry = {
                    ...nodeData,
                    mesh: mesh,
                    label: deviceLabels.length > 0 ? deviceLabels[deviceLabels.length - 1] : null
                };
                nodes.push(nodeEntry);

                devices.push(mesh);
            }

            // Render connection lines AFTER all devices are positioned
            const nodeMap = {};
            layoutNodes.forEach(n => nodeMap[n.id] = n);

            data.links.forEach(function (linkData, index) {
                const sourceNode = nodeMap[linkData.from];
                const targetNode = nodeMap[linkData.to];
                if (!sourceNode || !targetNode || !sourceNode.calculatedPosition || !targetNode.calculatedPosition) return;

                const sourcePos = new BABYLON.Vector3(
                    sourceNode.calculatedPosition.x,
                    sourceNode.calculatedPosition.y + 1.5, // Slightly elevated
                    sourceNode.calculatedPosition.z
                );
                const targetPos = new BABYLON.Vector3(
                    targetNode.calculatedPosition.x,
                    targetNode.calculatedPosition.y + 1.5,
                    targetNode.calculatedPosition.z
                );

                const line = BABYLON.MeshBuilder.CreateLines(`link_${index}`, {
                    points: [sourcePos, targetPos]
                }, scene);

                // Color code lines by type
                if (linkData.type === 'fortilink') {
                    line.color = new BABYLON.Color3(0.2, 0.8, 0.2); // Green for FortiLink
                } else if (linkData.type === 'wifi') {
                    line.color = new BABYLON.Color3(0.2, 0.6, 1.0); // Blue for WiFi
                } else {
                    line.color = new BABYLON.Color3(0.7, 0.7, 0.7); // Gray for wired
                }

                line.enableEdgesRendering();
                line.edgesWidth = 4.0;
                links.push(line);
            });

            logDebug(`‚úÖ Rendered ${devices.length} devices and ${links.length} links in hierarchical layout`);
        }

        let labModelManifest = null;


        async function loadLabModelManifest() {
            if (labModelManifest) return labModelManifest;
            try {
                const resp = await fetch('/lab_3d_models/manifest.json');
                if (!resp.ok) {
                    throw new Error('HTTP ' + resp.status);
                }
                const data = await resp.json();
                labModelManifest = data && Array.isArray(data.models) ? data : { models: [] };
            } catch (e) {
                console.log('Failed to load lab_3d_models manifest:', e);
                labModelManifest = { models: [] };
            }
            return labModelManifest;
        }


        function selectModelFromManifest(nodeData, manifest) {
            if (!manifest || !Array.isArray(manifest.models)) return null;

            const dt = (nodeData.type || nodeData.device_type || '').toLowerCase();
            let preferredCategories = [];
            if (dt.includes('fortigate') || dt.includes('firewall') || dt.includes('gateway')) {
                preferredCategories = ['firewall', 'security'];
            } else if (dt.includes('fortiswitch') || dt === 'switch') {
                preferredCategories = ['switch'];
            } else if (dt.includes('fortiap') || dt.includes('access_point') || dt.includes('wifi') || dt === 'ap') {
                preferredCategories = ['access_point'];
            }

            function matches(model) {
                const cat = String(model.category || '').toLowerCase();
                const name = String(model.name || '').toLowerCase();
                const tags = (model.tags || []).map((t) => String(t).toLowerCase());

                if (preferredCategories.length && preferredCategories.includes(cat)) {
                    return true;
                }

                if (dt.includes('fortigate') && (name.includes('fortigate') || name.includes('fg'))) {
                    return true;
                }
                if (dt.includes('fortiswitch') && (name.includes('fortiswitch') || name.includes('fs'))) {
                    return true;
                }
                if (dt.includes('fortiap') && (name.includes('fortiap') || name === 'ap')) {
                    return true;
                }

                if (tags.some((t) => t.includes('fortinet')) || name.includes('fortinet')) {
                    return true;
                }
                return false;
            }

            const candidates = manifest.models.filter((m) => m.objPath);
            for (const m of candidates) {
                if (matches(m)) {
                    const objRel = m.objPath;
                    return '/lab_3d_models/' + objRel.replace(/^\/*/, '');
                }
            }
            return null;
        }


        async function loadDeviceModel(nodeData, position) {
            // FORCE FALLBACK TO COLORED BOXES - skip all 3D model loading
            return null;

            const modelLoadErrors = [];
            const MAX_LOAD_TIMEOUT = 10000; // 10 seconds per model

            try {
                // TEMPORARILY DISABLED: VSS GLTF models load but materials don't render correctly
                // Using colored fallback boxes instead until we fix GLTF material loading
                const modelMap = {
                    // 'fortigate': '/vss_extraction/vss_exports/FortiGate_600E.gltf',
                    // 'fortiswitch': '/vss_extraction/vss_exports/FortiSwitch_148E.gltf',
                    // 'fortiap': '/vss_extraction/vss_exports/FortiAP_432F.gltf',
                    // 'client': '/static/3d-models/generic_device.obj'
                };

                const typeKey = (nodeData.type || '').toLowerCase();

                const manifest = await loadLabModelManifest();
                const manifestModel = selectModelFromManifest(nodeData, manifest);

                // Candidate model paths, in order of preference:
                // 1) model from API (lab-format `model` field, usually /lab_3d_models/...)
                // 2) model chosen from lab_3d_models/manifest.json
                // 3) VSS extraction modess_exports/)
                // 4) type-based fallback from modelMap
                // 5) generic client model
                const candidates = [];
                if (nodeData.model) {
                    candidates.push({ path: nodeData.model, source: 'API' });
                }
                if (manifestModel) {
                    candidates.push({ path: manifestModel, source: 'Manifest' });
                }
                // Add VSS models for Fortinet devices
                if (typeKey.includes('fortigate')) {
                    candidates.push({ path: modelMap['fortigate'], source: 'VSS' });
                } else if (typeKey.includes('fortiswitch')) {
                    candidates.push({ path: modelMap['fortiswitch'], source: 'VSS' });
                } else if (typeKey.includes('fortiap') || typeKey.includes('access_point')) {
                    candidates.push({ path: modelMap['fortiap'], source: 'VSS' });
                }
                // Always add generic fallback as last resort
                candidates.push({ path: modelMap['client'], source: 'Fallback' });

                for (let i = 0; i < candidates.length; i++) {
                    const candidate = candidates[i];
                    if (!candidate || !candidate.path || typeof candidate.path !== 'string') continue;

                    const lastSlash = candidate.path.lastIndexOf('/');
                    const rootUrl = lastSlash >= 0 ? candidate.path.substring(0, lastSlash + 1) : "";
                    const filename = lastSlash >= 0 ? candidate.path.substring(lastSlash + 1) : candidate.path;

                    logDebug(`Loading model [${i + 1}/${candidates.length}]: ${candidate.source} - ${filename}`);

                    try {
                        // Add timeout to model loading
                        const loadPromise = BABYLON.SceneLoader.ImportMeshAsync("", rootUrl, filename, scene);
                        const timeoutPromise = new Promise((_, reject) =>
                            setTimeout(() => reject(new Error('Model load timeout')), MAX_LOAD_TIMEOUT)
                        );

                        const result = await Promise.race([loadPromise, timeoutPromise]);

                        if (result && result.meshes && result.meshes.length > 0) {
                            // For GLTF files, use the root mesh or first mesh with geometry
                            let mesh = null;

                            // Try to find a mesh with actual geometry
                            for (let m of result.meshes) {
                                if (m.getTotalVertices && m.getTotalVertices() > 0) {
                                    mesh = m;
                                    break;
                                }
                            }

                            // If no mesh with vertices found, just use the first one
                            if (!mesh) {
                                mesh = result.meshes[0];
                            }

                            mesh.position = position;

                            // Scale the model MUCH larger (VSS-derived GLTFs are unit-sized, need 10x scale)
                            const scale = 10.0;
                            mesh.scaling = new BABYLON.Vector3(scale, scale, scale);

                            // Enhance materials for better visibility
                            if (mesh.material) {
                                logDebug(`üì¶ Model has material: ${mesh.material.name}`);
                                // Increase emissive to make model self-illuminated
                                if (mesh.material.emissiveColor) {
                                    const baseColor = mesh.material.diffuseColor || new BABYLON.Color3(0.8, 0.2, 0.2);
                                    mesh.material.emissiveColor = baseColor.scale(0.4);
                                }
                            } else {
                                logDebug('‚ö†Ô∏è  Model has no material, adding default');
                                // Add default material if missing
                                const defaultMat = new BABYLON.StandardMaterial(`default_${nodeData.id}`, scene);
                                defaultMat.diffuseColor = new BABYLON.Color3(0.8, 0.2, 0.2); // Red for FortiGate
                                defaultMat.emissiveColor = new BABYLON.Color3(0.3, 0.1, 0.1);
                                mesh.material = defaultMat;
                            }

                            // Also enhance all child meshes
                            result.meshes.forEach(childMesh => {
                                if (childMesh !== mesh && childMesh.material) {
                                    if (childMesh.material.emissiveColor) {
                                        const baseColor = childMesh.material.diffuseColor || new BABYLON.Color3(0.8, 0.2, 0.2);
                                        childMesh.material.emissiveColor = baseColor.scale(0.4);
                                    }
                                }
                            });

                            mesh.metadata = {
                                ...nodeData,
                                deviceType: nodeData.device_type || nodeData.type,
                                modelPath: candidate.path,
                                modelSource: candidate.source,
                                isRealisticModel: true,
                                loadSuccess: true
                            };

                            logDebug(`‚úÖ Successfully loaded ${candidate.source} model: ${filename}`);
                            return mesh;
                        } else {
                            throw new Error('No meshes returned from loader');
                        }
                    } catch (e) {
                        const errorMsg = e.message || String(e);
                        modelLoadErrors.push({
                            candidate: candidate.path,
                            source: candidate.source,
                            error: errorMsg
                        });
                        logDebug(`‚ùå Failed to load ${candidate.source} model (${filename}): ${errorMsg}`);
                        // Continue to next candidate
                    }
                }

                // All candidates failed - log summary
                logDebug(`‚ö†Ô∏è All ${candidates.length} model candidates failed for ${nodeData.name || 'unknown device'}`);
                if (modelLoadErrors.length > 0) {
                    console.group(`Model Load Failures for ${nodeData.name}`);
                    modelLoadErrors.forEach((err, idx) => {
                        console.log(`${idx + 1}. ${err.source}: ${err.candidate} - ${err.error}`);
                    });
                    console.groupEnd();
                }

            } catch (error) {
                const errorMsg = error.message || String(error);
                logDebug(`‚ùå Critical error loading 3D model for ${nodeData?.name || 'unknown'}: ${errorMsg}`);
                console.error('Model loading critical error:', error);
            }

            return null;
        }

        function createDeviceBox(nodeData, position) {
            // Create realistic Fortinet device models based on actual hardware photos
            const deviceGroup = new BABYLON.TransformNode(`${nodeData.id}_group`, scene);
            deviceGroup.position = position;

            let mainMesh;
            let color;
            let size;

            const type = (nodeData.type || '').toLowerCase();

            // ACTUAL FORTINET COLORS from photos:
            const fortinetWhite = new BABYLON.Color3(0.95, 0.95, 0.95); // FortiGate/FortiAP are WHITE
            const fortinetBeige = new BABYLON.Color3(0.88, 0.85, 0.78); // FortiSwitch is light beige/cream
            const ledGreen = new BABYLON.Color3(0.0, 1.0, 0.0);
            const ledOrange = new BABYLON.Color3(1.0, 0.5, 0.0);
            const portColor = new BABYLON.Color3(0.15, 0.15, 0.15);

            if (type.includes('fortigate') || type.includes('firewall')) {
                // FortiGate: WHITE 1U rackmount with FORTINET branding and green LEDs
                size = { width: 15, height: 3, depth: 8 };
                color = fortinetWhite;

                mainMesh = BABYLON.MeshBuilder.CreateBox(`${nodeData.id}_main`, size, scene);

                // Add green LED indicators on front (status lights)
                for (let i = 0; i < 5; i++) {
                    const led = BABYLON.MeshBuilder.CreateSphere(`${nodeData.id}_led${i}`, {
                        diameter: 0.4
                    }, scene);
                    led.position = new BABYLON.Vector3(
                        -2 + (i * 1),
                        -0.8,
                        size.depth / 2 + 0.05
                    );
                    led.parent = mainMesh;

                    const ledMat = new BABYLON.StandardMaterial(`${nodeData.id}_led${i}_mat`, scene);
                    ledMat.diffuseColor = ledGreen;
                    ledMat.emissiveColor = ledGreen.scale(0.8); // Glowing green
                    led.material = ledMat;
                }

                // Add Ethernet ports on the side
                for (let i = 0; i < 6; i++) {
                    const port = BABYLON.MeshBuilder.CreateBox(`${nodeData.id}_port${i}`, {
                        width: 0.6,
                        height: 0.8,
                        depth: 0.8
                    }, scene);
                    port.position = new BABYLON.Vector3(
                        -size.width / 2 - 0.3,
                        0,
                        -2 + (i * 1.2)
                    );
                    port.parent = mainMesh;

                    const portMat = new BABYLON.StandardMaterial(`${nodeData.id}_port${i}_mat`, scene);
                    portMat.diffuseColor = portColor;
                    port.material = portMat;
                }

            } else if (type.includes('fortiswitch') || type.includes('switch')) {
                // FortiSwitch: BEIGE 1U rackmount with Ethernet ports - matches photo
                size = { width: 15, height: 2.5, depth: 6 };
                color = fortinetBeige;

                mainMesh = BABYLON.MeshBuilder.CreateBox(`${nodeData.id}_main`, size, scene);

                // Add Ethernet ports on the side (like in photo)
                for (let i = 0; i < 16; i++) {
                    const port = BABYLON.MeshBuilder.CreateBox(`${nodeData.id}_port${i}`, {
                        width: 0.4,
                        height: 0.6,
                        depth: 0.6
                    }, scene);
                    port.position = new BABYLON.Vector3(
                        -size.width / 2 - 0.2,
                        0.3,
                        -2.5 + (i * 0.35)
                    );
                    port.parent = mainMesh;

                    const portMat = new BABYLON.StandardMaterial(`${nodeData.id}_port${i}_mat`, scene);
                    portMat.diffuseColor = portColor;
                    port.material = portMat;

                    // Add green LED above some ports
                    if (i < 8) {
                        const led = BABYLON.MeshBuilder.CreateSphere(`${nodeData.id}_led${i}`, {
                            diameter: 0.15
                        }, scene);
                        led.position = new BABYLON.Vector3(
                            -size.width / 2 - 0.2,
                            0.9,
                            -2.5 + (i * 0.35)
                        );
                        led.parent = mainMesh;

                        const ledMat = new BABYLON.StandardMaterial(`${nodeData.id}_led${i}_mat`, scene);
                        ledMat.diffuseColor = ledGreen;
                        ledMat.emissiveColor = ledGreen.scale(0.8);
                        led.material = ledMat;
                    }
                }

            } else if (type.includes('fortiap') || type.includes('access') || type.includes('ap')) {
                // FortiAP 231F: WHITE ROUNDED SQUARE (flat profile) - matches photo exactly
                size = { width: 6, height: 1, depth: 6 };
                color = fortinetWhite;

                // Create rounded square using box with slightly beveled edges
                mainMesh = BABYLON.MeshBuilder.CreateBox(`${nodeData.id}_main`, size, scene);
                // Note: Could use CreateBox with faceUV for more detail, but this works

                // Add colorful LED row on front (green, orange indicators like in photo)
                const ledColors = [ledGreen, ledGreen, ledOrange, ledOrange, ledOrange];
                for (let i = 0; i < 5; i++) {
                    const led = BABYLON.MeshBuilder.CreateSphere(`${nodeData.id}_led${i}`, {
                        diameter: 0.3
                    }, scene);
                    led.position = new BABYLON.Vector3(
                        -1.5 + (i * 0.75),
                        size.height / 2 + 0.05,
                        size.depth / 2 - 1
                    );
                    led.parent = mainMesh;

                    const ledMat = new BABYLON.StandardMaterial(`${nodeData.id}_led${i}_mat`, scene);
                    ledMat.diffuseColor = ledColors[i];
                    ledMat.emissiveColor = ledColors[i].scale(0.9); // Bright glowing LEDs
                    led.material = ledMat;
                }

            } else {
                // Generic client device - simple gray box
                size = { width: 3, height: 2, depth: 2 };
                color = new BABYLON.Color3(0.5, 0.5, 0.5);
                mainMesh = BABYLON.MeshBuilder.CreateBox(`${nodeData.id}_main`, size, scene);
            }

            // Apply material to main mesh
            const material = new BABYLON.StandardMaterial(`${nodeData.id}_mat`, scene);
            material.diffuseColor = color;
            material.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
            material.emissiveColor = color.scale(0.15); // Slight self-illumination
            mainMesh.material = material;

            mainMesh.parent = deviceGroup;

            deviceGroup.metadata = {
                ...nodeData,
                deviceType: nodeData.device_type || nodeData.type,
                mesh: mainMesh
            };

            return deviceGroup;
        }

        function createDeviceLabel(nodeData, mesh) {
            try {
                const nameText = nodeData.name || 'Device';
                const ipText = nodeData.ip || '';
                const macText = nodeData.mac || '';
                const vlanText = (nodeData.vlan !== undefined && nodeData.vlan !== null)
                    ? String(nodeData.vlan)
                    : '';
                const dtWidth = 256;
                const dtHeight = 112;
                const texture = new BABYLON.DynamicTexture(`${nodeData.id} _label_tex`, { width: dtWidth, height: dtHeight }, scene, false);
                texture.hasAlpha = true;
                const font = "20px 'Segoe UI'";

                // High-contrast background for readability
                let y = 34;
                texture.drawText(nameText, null, y, font, "#ffffff", "rgba(10, 12, 30, 0.95)", true);
                if (ipText) {
                    y += 24;
                    texture.drawText(ipText, null, y, font, "#a8c5ff", null, true);
                }

                const detailParts = [];
                if (vlanText) {
                    detailParts.push(`VLAN: ${vlanText} `);
                }
                if (macText) {
                    // Use full MAC address in label
                    detailParts.push(`MAC: ${macText} `);
                }
                if (detailParts.length > 0) {
                    y += 24;
                    texture.drawText(detailParts.join('  ¬∑  '), null, y, font, "#d0d7ff", null, true);
                }

                const labelMat = new BABYLON.StandardMaterial(`${nodeData.id} _label_mat`, scene);
                labelMat.diffuseTexture = texture;
                labelMat.emissiveColor = new BABYLON.Color3(1, 1, 1);
                labelMat.backFaceCulling = false;

                // Slightly larger plane and position just below the icon, above the ground
                const labelPlane = BABYLON.MeshBuilder.CreatePlane(`${nodeData.id} _label`, { width: 3.2, height: 1.1 }, scene);
                labelPlane.parent = mesh;
                labelPlane.position = new BABYLON.Vector3(0, 0.5, 0);
                labelPlane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
                labelPlane.material = labelMat;
                deviceLabels.push(labelPlane);
            } catch (e) {
                console.log('Failed to create label for', nodeData && nodeData.name, e);
            }
        }

        async function addSVGOverlay(nodeData, mesh) {
            try {
                // Map device types to realistic SVG files (fallbacks)
                const svgMap = {
                    'fortigate': '/realistic_device_svgs/FortiGate.svg',
                    'fortiswitch': '/realistic_device_svgs/FortiSwitch.svg',
                    'fortiap': '/realistic_device_svgs/FortiAP.svg',
                    'client': '/realistic_device_svgs/Laptop.svg'
                };

                const typeKey = (nodeData.type || '').toLowerCase();

                // Prefer icon_svg from the API (VSS‚ÜíSVG), fall back to type-based SVG
                const svgPath = nodeData.icon_svg || svgMap[typeKey] || svgMap['client'];

                // Create a small plane for 2D overlay
                const overlay = BABYLON.MeshBuilder.CreatePlane(`${nodeData.id} _overlay`,
                    { width: 3, height: 2 }, scene);
                overlay.position = new BABYLON.Vector3(
                    mesh.position.x,
                    mesh.position.y + 2.5,
                    mesh.position.z
                );
                overlay.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

                // Create material with SVG texture
                const overlayMaterial = new BABYLON.StandardMaterial(`${nodeData.id} _overlay_mat`, scene);

                // Try to load SVG as texture
                try {
                    const texture = new BABYLON.Texture(svgPath, scene);
                    overlayMaterial.diffuseTexture = texture;
                    overlayMaterial.emissiveColor = new BABYLON.Color3(0.8, 0.8, 0.8);
                    overlayMaterial.backFaceCulling = false;
                } catch (e) {
                    console.log(`Failed to load SVG texture for ${nodeData.name}: `, e);
                    // Fallback to device-type color
                    overlayMaterial.diffuseColor = new BABYLON.Color3(0.9, 0.9, 0.9);
                    overlayMaterial.emissiveColor = new BABYLON.Color3(0.3, 0.3, 0.3);
                }

                overlay.material = overlayMaterial;

                // Parent overlay to mesh
                overlay.parent = mesh;

                // Track which SVG was actually used so we can display it in the UI
                if (!mesh.metadata) {
                    mesh.metadata = { ...nodeData };
                }
                mesh.metadata.iconSvgPath = svgPath;

            } catch (error) {
                console.log(`Failed to add SVG overlay for ${nodeData.name}:`, error);
            }
        }

        function initUI() {
            document.getElementById('loadTopologyBtn').addEventListener('click', loadTopologyFromLab);

            document.getElementById('autoRotateBtn').addEventListener('click', () => {
                autoRotate = !autoRotate;
                document.getElementById('autoRotateBtn').classList.toggle('active', autoRotate);
            });

            document.getElementById('resetViewBtn').addEventListener('click', () => {
                if (camera) {
                    camera.alpha = 0;
                    camera.beta = Math.PI / 3;
                    camera.radius = 30;
                }
            });

            document.getElementById('labelsBtn').addEventListener('click', () => {
                labelsVisible = !labelsVisible;
                const btn = document.getElementById('labelsBtn');
                btn.classList.toggle('active', labelsVisible);
                deviceLabels.forEach(label => {
                    if (label) label.isVisible = labelsVisible;
                });
            });

            const exportDrawIOXmlBtn = document.getElementById('exportDrawIOXmlBtn');
            const exportDrawIO3DSceneBtn = document.getElementById('exportDrawIO3DSceneBtn');
            if (exportDrawIOXmlBtn) {
                exportDrawIOXmlBtn.addEventListener('click', exportDrawIOXml);
            }
            if (exportDrawIO3DSceneBtn) {
                exportDrawIO3DSceneBtn.addEventListener('click', exportDrawIO3DScene);
            }

            cdebarToggle = document.getElementById('sidebarToggle');
            const leftSidebar = document.getElementById('leftSidebar');
            sidebarToggle.addEventListener('click', () => {
                leftSidebar.classList.toggle('open');
            });
        }


        async function exportDrawIOXml() {
            try {
                updateStatus('Exporting DrawIO XML...');
                showLoading();
                const resp = await fetch('/api/topology/drawio-xml', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ layout: 'hierarchical', group_by: 'type', show_details: true, color_code: true })
                });
                if (!resp.ok) {
                    const text = await resp.text();
                    throw new Error('HTTP ' + resp.status + ': ' + text);
                }
                const xmlText = await resp.text();
                const blob = new Blob([xmlText], { type: 'application/xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'fortinet_topology.drawio';
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                updateStatus('DrawIO XML exported');
            } catch (err) {
                console.error('Failed to export DrawIO XML:', err);
                showError(err.message || String(err));
                updateStatus('Error');
            } finally {
                hideLoading();
            }
        }


        async function exportDrawIO3DScene() {
            try {
                updateStatus('Exporting 3D scene JSON...');
                showLoading();
                const resp = await fetch('/api/topology/drawio-3d-scene', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ layout: 'hierarchical', group_by: 'type', show_details: true, color_code: true })
                });
                if (!resp.ok) {
                    const text = await resp.text();
                    throw new Error('HTTP ' + resp.status + ': ' + text);
                }
                const sceneData = await resp.json();
                const blob = new Blob([JSON.stringify(sceneData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'fortinet_scene.json';
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                updateStatus('3D scene JSON exported');
            } catch (err) {
                console.error('Failed to export 3D scene JSON:', err);
                showError(err.message || String(err));
                updateStatus('Error');
            } finally {
                hideLoading();
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            initBabylon();
            initUI();
            // Automatically load the lab topology on page load so the canvas is never blank
            loadTopologyFromLab();
        });
    </script>
</body>

</html>