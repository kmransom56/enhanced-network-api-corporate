<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced 2D Fortinet Network Topology (D3.js)</title>
    <link rel="stylesheet" href="/static/2d_topology_enhanced.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        .node {
            cursor: move;
        }
        .node:hover {
            stroke-width: 3px;
        }
        .link {
            fill: none;
            stroke: #999;
            stroke-width: 2px;
            stroke-opacity: 0.6;
        }
        .link:hover {
            stroke-width: 3px;
            stroke-opacity: 1;
        }
        .node-label {
            font-size: 12px;
            font-weight: bold;
            pointer-events: none;
            text-anchor: middle;
        }
        .tooltip {
            position: absolute;
            padding: 10px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 5px;
            pointer-events: none;
            font-size: 12px;
            z-index: 1000;
        }
        .zoom-controls {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
        }
        .zoom-btn {
            display: block;
            margin: 5px;
            padding: 8px 12px;
            background: #fff;
            border: 1px solid #ccc;
            border-radius: 4px;
            cursor: pointer;
        }
        .zoom-btn:hover {
            background: #f0f0f0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="controls">
            <h1>üåê Enhanced 2D Fortinet Network Topology (D3.js Interactive)</h1>
            <div class="button-group">
                <button onclick="loadFortinetTopology()">üî• Load Fortinet</button>
                <button onclick="loadDemoTopology()">üé≠ Demo Mode</button>
                <button onclick="toggleDeviceLabels()">üè∑Ô∏è Labels</button>
                <button onclick="toggleHealthStatus()">üíö Health</button>
                <button onclick="resetView()">üîÑ Reset View</button>
            </div>
        </div>
        
        <div class="topology-container" style="position: relative;">
            <div class="zoom-controls">
                <button class="zoom-btn" onclick="zoomIn()">üîç+ Zoom In</button>
                <button class="zoom-btn" onclick="zoomOut()">üîç- Zoom Out</button>
                <button class="zoom-btn" onclick="resetZoom()">üìç Reset Zoom</button>
            </div>
            <svg id="topology-svg" width="100%" height="100%"></svg>
            <div class="tooltip" id="tooltip" style="display: none;"></div>
            <div class="info-panel">
                <h3>Network Status</h3>
                <p>Devices: <span id="device-count">0</span></p>
                <p>Connections: <span id="connection-count">0</span></p>
                <p>Health: <span id="health-status">Good</span></p>
            </div>
        </div>
    </div>

    <script>
        // Enhanced 2D Topology Visualization with D3.js
        class Enhanced2DTopology {
            constructor() {
                this.svg = d3.select('#topology-svg');
                this.devices = new Map();
                this.connections = [];
                this.showLabels = true;
                this.showHealth = true;
                this.svgNS = "http://www.w3.org/2000/svg";
                this.zoom = null;
                this.tooltip = d3.select('#tooltip');
                this.currentData = null;
                
                // Device icon configurations with model-specific fallback
                const deviceIcons = {
                    'fortigate': '/static/fortinet-icons-extracted/FortiGate.svg',
                    'fortiswitch': '/static/fortinet-icons-extracted/FortiSwitch.svg', 
                    'fortiap': '/static/fortinet-icons-extracted/FortiAP.svg',
                    'fortimanager': '/static/fortinet-icons-extracted/FortiManager.svg',
                    'fortianalyzer': '/static/fortinet-icons-extracted/FortiAnalyzer.svg',
                    'default': '/static/fortinet-icons-extracted/Virtual.svg'
                };
                
                // Model-specific icon mapping - make it a class property
                this.modelSpecificIcons = {
                    'FortiGate_600E': '/static/model-specific-icons/FortiGate_600E.svg',
                    'FortiSwitch_148E': '/static/model-specific-icons/FortiSwitch_148E.svg',
                    'FortiAP_432F': '/static/model-specific-icons/FortiAP_432F.svg'
                };
                
                this.deviceIcons = {
                    'fortigate': {
                        icon: deviceIcons['fortigate'],
                        size: 60,
                        color: '#ff6b6b',
                        labelColor: '#ff6b6b'
                    },
                    'fortiswitch': {
                        icon: deviceIcons['fortiswitch'],
                        size: 50,
                        color: '#4ecdc4',
                        labelColor: '#4ecdc4'
                    },
                    'fortiap': {
                        icon: deviceIcons['fortiap'],
                        size: 45,
                        color: '#45b7d1',
                        labelColor: '#45b7d1'
                    },
                    'fortimanager': {
                        icon: deviceIcons['fortimanager'],
                        size: 55,
                        color: '#9b59b6',
                        labelColor: '#9b59b6'
                    },
                    'fortianalyzer': {
                        icon: deviceIcons['fortianalyzer'],
                        size: 55,
                        color: '#e67e22',
                        labelColor: '#e67e22'
                    },
                    'default': {
                        icon: '/static/fortinet-icons-extracted/Virtual.svg',
                        size: 40,
                        color: '#95a5a6',
                        labelColor: '#95a5a6'
                    }
                };
                
                this.init();
            }
            
            init() {
                this.setupD3SVG();
                this.setupEventListeners();
                console.log('‚úÖ Enhanced 2D Topology with D3.js initialized');
            }
            
            setupD3SVG() {
                // Set up SVG dimensions
                const width = this.svg.node().getBoundingClientRect().width || 1200;
                const height = this.svg.node().getBoundingClientRect().height || 800;
                
                // Create container group for zoom/pan
                this.g = this.svg.append('g').attr('class', 'topology-container');
                
                // Set up zoom behavior
                this.zoom = d3.zoom()
                    .scaleExtent([0.1, 4])
                    .on('zoom', (event) => {
                        this.g.attr('transform', event.transform);
                    });
                
                this.svg.call(this.zoom);
                
                // Create groups for links and nodes (links first so nodes appear on top)
                this.linkGroup = this.g.append('g').attr('class', 'links');
                this.nodeGroup = this.g.append('g').attr('class', 'nodes');
                
                console.log('‚úÖ D3.js SVG setup complete');
            }
                
                // Create definitions for gradients and filters
                const defs = document.createElementNS(this.svgNS, 'defs');
                
                // Add gradients for devices
                Object.entries(this.deviceIcons).forEach(([type, config]) => {
                    const gradient = document.createElementNS(this.svgNS, 'radialGradient');
                    gradient.setAttribute('id', `gradient-${type}`);
                    
                    const stop1 = document.createElementNS(this.svgNS, 'stop');
                    stop1.setAttribute('offset', '0%');
                    stop1.setAttribute('stop-color', config.color);
                    stop1.setAttribute('stop-opacity', '0.8');
                    
                    const stop2 = document.createElementNS(this.svgNS, 'stop');
                    stop2.setAttribute('offset', '100%');
                    stop2.setAttribute('stop-color', config.color);
                    stop2.setAttribute('stop-opacity', '0.3');
                    
                    gradient.appendChild(stop1);
                    gradient.appendChild(stop2);
                    defs.appendChild(gradient);
                });
                
                // Add shadow filter
                const filter = document.createElementNS(this.svgNS, 'filter');
                filter.setAttribute('id', 'shadow');
                
                const feGaussianBlur = document.createElementNS(this.svgNS, 'feGaussianBlur');
                feGaussianBlur.setAttribute('in', 'SourceAlpha');
                feGaussianBlur.setAttribute('stdDeviation', '3');
                
                const feOffset = document.createElementNS(this.svgNS, 'feOffset');
                feOffset.setAttribute('dx', '2');
                feOffset.setAttribute('dy', '2');
                feOffset.setAttribute('result', 'offsetblur');
                
                const feComponentTransfer = document.createElementNS(this.svgNS, 'feComponentTransfer');
                const feFuncA = document.createElementNS(this.svgNS, 'feFuncA');
                feFuncA.setAttribute('type', 'linear');
                feFuncA.setAttribute('slope', '0.3');
                feComponentTransfer.appendChild(feFuncA);
                
                const feMerge = document.createElementNS(this.svgNS, 'feMerge');
                const feMergeNode1 = document.createElementNS(this.svgNS, 'feMergeNode');
                const feMergeNode2 = document.createElementNS(this.svgNS, 'feMergeNode');
                feMergeNode2.setAttribute('in', 'SourceGraphic');
                feMerge.appendChild(feMergeNode1);
                feMerge.appendChild(feMergeNode2);
                
                filter.appendChild(feGaussianBlur);
                filter.appendChild(feOffset);
                filter.appendChild(feComponentTransfer);
                filter.appendChild(feMerge);
                defs.appendChild(filter);
                
                this.svg.appendChild(defs);
                
                // Create main group for topology
                this.topologyGroup = document.createElementNS(this.svgNS, 'g');
                this.topologyGroup.setAttribute('id', 'topology-group');
                this.svg.appendChild(this.topologyGroup);
            }
            
            setupEventListeners() {
                // Handle window resize
                window.addEventListener('resize', () => this.handleResize());
                
                // Handle device interactions
                this.svg.addEventListener('click', (e) => this.handleDeviceClick(e));
                this.svg.addEventListener('mousemove', (e) => this.handleMouseMove(e));
            }
            
            handleResize() {
                const rect = this.svg.getBoundingClientRect();
                this.svg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);
            }
            
            async loadFortinetTopology() {
                try {
                    console.log('üî• Loading Fortinet topology...');
                    const response = await fetch('/api/topology/scene');
                    const data = await response.json();
                    
                    if (data.nodes && data.links) {
                        // Filter out interface nodes - only show actual devices
                        const filteredNodes = data.nodes.filter(node => {
                            const type = (node.type || '').toLowerCase();
                            const id = (node.id || '').toLowerCase();
                            // Exclude interface, port, vlan, tunnel, and other non-device nodes
                            return !type.includes('interface') && 
                                   !type.includes('port') && 
                                   !type.includes('vlan') && 
                                   !type.includes('tunnel') && 
                                   !type.includes('vap-switch') && 
                                   !type.includes('aggregate') && 
                                   !id.startsWith('port-') &&
                                   !id.startsWith('if-');
                        });
                        
                        // Filter links to only include connections between filtered nodes
                        const nodeIds = new Set(filteredNodes.map(n => n.id));
                        const filteredLinks = data.links.filter(link => {
                            const source = link.from || link.source || link.source_id;
                            const target = link.to || link.target || link.target_id;
                            return nodeIds.has(source) && nodeIds.has(target);
                        });
                        
                        const filteredData = { nodes: filteredNodes, links: filteredLinks };
                        this.renderTopology(filteredData);
                        this.updateStats(filteredNodes.length, filteredLinks.length);
                    } else {
                        this.showError('Invalid topology data received');
                    }
                } catch (error) {
                    console.error('Failed to load Fortinet topology:', error);
                    this.showError('Failed to load topology: ' + error.message);
                }
            }
            
            loadDemoTopology() {
                const demoData = {
                    nodes: [
                        { 
                            id: "fg-600e-main", 
                            type: "fortigate", 
                            name: "FG-600E-Main", 
                            model: "FortiGate_600E",
                            ip: "192.168.0.254",
                            status: "active",
                            health: "good",
                            cpu: "15%",
                            memory: "45%",
                            connections: 12,
                            throughput: "1.2 Gbps",
                            sessions: 2847,
                            serial: "FG600E1234567890",
                            version: "v7.0.0"
                        },
                        { 
                            id: "fmg-200f", 
                            type: "fortimanager", 
                            name: "FMG-200F-Corp", 
                            ip: "192.168.0.10",
                            status: "online",
                            health: "good",
                            model: "FortiManager 200F",
                            serial: "FMG200F1234567890",
                            version: "v7.2.0"
                        },
                        { 
                            id: "faz-100f", 
                            type: "fortianalyzer", 
                            name: "FAZ-100F-Log", 
                            ip: "192.168.0.20",
                            status: "online",
                            health: "good",
                            model: "FortiAnalyzer 100F",
                            serial: "FAZ100F1234567890",
                            version: "v7.0.0"
                        },
                        { 
                            id: "fsw-148e-core", 
                            type: "fortiswitch", 
                            name: "FS-148E-CoreSwitch", 
                            model: "FortiSwitch_148E",
                            ip: "192.168.0.100",
                            status: "active",
                            health: "good",
                            cpu: "8%",
                            memory: "32%",
                            ports: 48,
                            uptime: "45 days",
                            vlans: 12,
                            serial: "FS148E1234567890",
                            version: "v7.0.0"
                        },
                        { 
                            id: "fsw-124e-access", 
                            type: "fortiswitch", 
                            name: "FS-124E-Access01", 
                            ip: "192.168.0.101",
                            status: "online",
                            health: "warning",
                            serial: "FS124E1234567890",
                            version: "v7.0.0"
                        },
                        { 
                            id: "fap-432f-office", 
                            type: "fortiap", 
                            name: "FAP-432F-Office01", 
                            model: "FortiAP_432F",
                            ip: "192.168.0.110",
                            status: "active",
                            health: "good",
                            clients: 24,
                            ssid: "CORP-WIFI",
                            channel: 36,
                            band: "5GHz",
                            throughput: "1.2 Gbps",
                            serial: "FAP432F1234567890",
                            version: "v7.0.0"
                        },
                        { 
                            id: "fap-231f-guest", 
                            type: "fortiap", 
                            name: "FAP-231F-Guest01", 
                            ip: "192.168.0.111",
                            status: "online",
                            health: "good",
                            model: "FortiAP 231F",
                            serial: "FAP231F1234567890",
                            version: "v7.0.0"
                        },
                        { 
                            id: "fap-224f-warehouse", 
                            type: "fortiap", 
                            name: "FAP-224F-Warehouse01", 
                            ip: "192.168.0.112",
                            status: "offline",
                            health: "critical",
                            model: "FortiAP 224F",
                            serial: "FAP224F1234567890",
                            version: "v7.0.0"
                        }
                    ],
                    links: [
                        { from: "fg-600e-main", to: "fmg-200f", type: "mgmt", status: "active" },
                        { from: "fg-600e-main", to: "faz-100f", type: "log", status: "active" },
                        { from: "fg-600e-main", to: "fsw-148e-core", type: "fortilink", status: "active" },
                        { from: "fg-600e-main", to: "fsw-124e-access", type: "fortilink", status: "active" },
                        { from: "fsw-148e-core", to: "fsw-124e-access", type: "cascade", status: "active" },
                        { from: "fsw-148e-core", to: "fap-432f-office", type: "wired", status: "active" },
                        { from: "fsw-124e-access", to: "fap-231f-guest", type: "wired", status: "active" },
                        { from: "fsw-124e-access", to: "fap-224f-warehouse", type: "wired", status: "error" }
                    ]
                };
                
                this.renderTopology(demoData);
                this.updateStats(demoData.nodes.length, demoData.links.length);
            }
            
            renderTopology(data) {
                this.currentData = data;
                this.clearTopology();
                
                const width = this.svg.node().getBoundingClientRect().width || 1200;
                const height = this.svg.node().getBoundingClientRect().height || 800;
                
                // Network Tree Layout - Hierarchical layout matching Fortinet topology diagram
                const positions = this.calculateNetworkTreeLayout(data.nodes, data.links, width, height);
                
                // Update node positions
                data.nodes.forEach(node => {
                    const pos = positions[node.id] || { x: width / 2, y: height / 2 };
                    node.x = pos.x;
                    node.y = pos.y;
                });
                
                // Create node map for link resolution
                const nodeMap = new Map(data.nodes.map(n => [n.id, n]));
                
                // Normalize links and resolve to node objects
                const links = data.links
                    .map(link => {
                        const sourceId = link.from || link.source || link.source_id;
                        const targetId = link.to || link.target || link.target_id;
                        const sourceNode = nodeMap.get(sourceId);
                        const targetNode = nodeMap.get(targetId);
                        
                        if (!sourceNode || !targetNode) return null; // Skip invalid links
                        
                        return {
                            source: sourceNode,
                            target: targetNode,
                            type: link.type || 'default',
                            status: link.status || 'active',
                            ports: link.ports || link.interfaces || []
                        };
                    })
                    .filter(link => link !== null); // Remove invalid links
                
                // Create D3.js links - use enter/update/exit pattern
                const linkSelection = this.linkGroup.selectAll('.link')
                    .data(links, d => `${d.source.id}-${d.target.id}`);
                
                // Remove old links
                linkSelection.exit().remove();
                
                // Add new links
                const linkEnter = linkSelection.enter()
                    .append('line')
                    .attr('class', 'link')
                    .attr('stroke', d => d.status === 'active' ? '#999' : '#f00')
                    .attr('stroke-width', 2)
                    .attr('stroke-opacity', 0.6);
                
                // Merge enter and update
                const linkUpdate = linkEnter.merge(linkSelection);
                
                // Create D3.js nodes with drag - use enter/update/exit pattern
                const nodeSelection = this.nodeGroup.selectAll('.node')
                    .data(data.nodes, d => d.id);
                
                // Remove old nodes
                nodeSelection.exit().remove();
                
                // Add new nodes
                const nodeEnter = nodeSelection.enter()
                    .append('g')
                    .attr('class', 'node')
                    .call(this.dragHandler());
                
                // Add circles for nodes (only on enter)
                nodeEnter.append('circle')
                    .attr('r', d => this.getNodeSize(d))
                    .attr('fill', d => this.getNodeColor(d))
                    .attr('stroke', d => this.getNodeColor(d))
                    .attr('stroke-width', 2);
                
                // Add labels (only on enter, toggle visibility later)
                const labels = nodeEnter.append('text')
                    .attr('class', 'node-label')
                    .attr('dy', d => this.getNodeSize(d) + 15)
                    .attr('fill', d => this.getNodeColor(d))
                    .text(d => d.name || d.id)
                    .style('display', this.showLabels ? 'block' : 'none');
                
                // Add tooltips
                nodeEnter
                    .on('mouseover', (event, d) => this.showTooltip(event, d))
                    .on('mousemove', (event) => this.moveTooltip(event))
                    .on('mouseout', () => this.hideTooltip());
                
                // Merge enter and update, then update positions
                const nodeUpdate = nodeEnter.merge(nodeSelection);
                nodeUpdate.attr('transform', d => `translate(${d.x},${d.y})`);
                
                // Store selections for later updates
                this.nodeSelection = nodeUpdate;
                this.linkSelection = linkUpdate;
                
                // Update link positions
                this.updateLinks();
                
                console.log(`‚úÖ Rendered ${data.nodes.length} devices and ${data.links.length} connections with D3.js`);
            }
            
            dragHandler() {
                const self = this;
                return d3.drag()
                    .on('start', function(event, d) {
                        if (!event.active) self.zoom.scaleBy(self.svg.transition().duration(0), 1);
                        d3.select(this).raise().attr('stroke', '#000').attr('stroke-width', 3);
                    })
                    .on('drag', function(event, d) {
                        d.x = event.x;
                        d.y = event.y;
                        d3.select(this).attr('transform', `translate(${d.x},${d.y})`);
                        self.updateLinks();
                    })
                    .on('end', function(event, d) {
                        d3.select(this).attr('stroke', null).attr('stroke-width', null);
                    });
            }
            
            updateLinks() {
                if (!this.linkSelection || !this.nodeSelection) return;
                
                // Links now have node objects directly (from renderTopology)
                // So we can access x and y directly from the node objects
                this.linkSelection
                    .attr('x1', d => {
                        const source = typeof d.source === 'object' && d.source !== null ? d.source : null;
                        return source && source.x !== undefined ? source.x : 0;
                    })
                    .attr('y1', d => {
                        const source = typeof d.source === 'object' && d.source !== null ? d.source : null;
                        return source && source.y !== undefined ? source.y : 0;
                    })
                    .attr('x2', d => {
                        const target = typeof d.target === 'object' && d.target !== null ? d.target : null;
                        return target && target.x !== undefined ? target.x : 0;
                    })
                    .attr('y2', d => {
                        const target = typeof d.target === 'object' && d.target !== null ? d.target : null;
                        return target && target.y !== undefined ? target.y : 0;
                    });
            }
            
            getNodeSize(node) {
                const type = (node.type || '').toLowerCase();
                if (type.includes('fortigate')) return 30;
                if (type.includes('switch')) return 25;
                if (type.includes('ap')) return 22;
                return 20;
            }
            
            getNodeColor(node) {
                const type = (node.type || '').toLowerCase();
                if (type.includes('fortigate')) return '#ff6b6b';
                if (type.includes('switch')) return '#4ecdc4';
                if (type.includes('ap')) return '#45b7d1';
                if (type.includes('client') || type.includes('endpoint')) return '#95a5a6';
                return '#9b59b6';
            }
            
            showTooltip(event, node) {
                const tooltipContent = `
                    <strong>${node.name || node.id}</strong><br/>
                    Type: ${node.type || 'Unknown'}<br/>
                    ${node.ip ? `IP: ${node.ip}<br/>` : ''}
                    ${node.model ? `Model: ${node.model}<br/>` : ''}
                    ${node.status ? `Status: ${node.status}` : ''}
                `;
                this.tooltip
                    .html(tooltipContent)
                    .style('display', 'block')
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            }
            
            moveTooltip(event) {
                this.tooltip
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px');
            }
            
            hideTooltip() {
                this.tooltip.style('display', 'none');
            }
            
            calculateNetworkTreeLayout(nodes, links, width, height) {
                const positions = {};
                const nodeMap = {};
                nodes.forEach(n => nodeMap[n.id] = n);
                
                // Spacing configuration for 2D SVG
                const spacing = {
                    vertical: height / 6,      // Vertical spacing between layers
                    horizontal: width / 4,     // Horizontal spacing between branches
                    device: width / 12,         // Spacing between devices in same group
                };
                
                // Build parent-child relationships from actual links with port information
                const childrenByParent = {};  // parent -> [{id, port, portNumber}]
                const parentByChild = {};     // child -> parent
                const portByConnection = {};  // child -> port number on parent
                
                // Helper to extract port number from port string (e.g., "port5" -> 5)
                const extractPortNumber = (portStr) => {
                    if (!portStr) return null;
                    const match = portStr.toString().match(/(\d+)/);
                    return match ? parseInt(match[1], 10) : null;
                };
                
                links.forEach(link => {
                    const source = link.from || link.source || link.source_id;
                    const target = link.to || link.target || link.target_id;
                    if (!source || !target || source === target) return;
                    
                    const sourceNode = nodeMap[source];
                    const targetNode = nodeMap[target];
                    if (!sourceNode || !targetNode) return;
                    
                    // Extract port information
                    const ports = link.ports || link.interfaces || [];
                    const sourcePort = Array.isArray(ports) ? ports[0] : null;
                    const targetPort = Array.isArray(ports) && ports.length > 1 ? ports[1] : null;
                    
                    const sourceType = ((sourceNode.type || sourceNode.role || '') + ' ' + (sourceNode.os || '')).toLowerCase();
                    const targetType = ((targetNode.type || targetNode.role || '') + ' ' + (targetNode.os || '')).toLowerCase();
                    
                    // Determine hierarchy based on device types
                    let parent = null;
                    let child = null;
                    let switchPort = null; // Port on the switch/AP that connects to the child
                    
                    // Internet ‚Üí Fortigate
                    if (sourceType.includes('internet') || sourceType.includes('wan')) {
                        parent = source;
                        child = target;
                    } else if (targetType.includes('internet') || targetType.includes('wan')) {
                        parent = target;
                        child = source;
                    }
                    // Fortigate ‚Üí Switch/AP
                    else if (sourceType.includes('fortigate') || sourceType.includes('fortios') || sourceType.includes('firewall')) {
                        if (targetType.includes('switch') || targetType.includes('ap') || targetType.includes('fortiswitch') || targetType.includes('fortiap')) {
                            parent = source;
                            child = target;
                        }
                    } else if (targetType.includes('fortigate') || targetType.includes('fortios') || targetType.includes('firewall')) {
                        if (sourceType.includes('switch') || sourceType.includes('ap') || sourceType.includes('fortiswitch') || sourceType.includes('fortiap')) {
                            parent = target;
                            child = source;
                        }
                    }
                    // Switch/AP ‚Üí Clients/Endpoints
                    else if (sourceType.includes('switch') || sourceType.includes('fortiswitch') || sourceType.includes('meraki') || sourceType.includes('ap') || sourceType.includes('fortiap')) {
                        if (!targetType.includes('fortigate') && !targetType.includes('internet') && !targetType.includes('switch') && !targetType.includes('ap')) {
                            parent = source;
                            child = target;
                            switchPort = sourcePort; // Port on the switch
                        }
                    } else if (targetType.includes('switch') || targetType.includes('fortiswitch') || targetType.includes('meraki') || targetType.includes('ap') || targetType.includes('fortiap')) {
                        if (!sourceType.includes('fortigate') && !sourceType.includes('internet') && !sourceType.includes('switch') && !sourceType.includes('ap')) {
                            parent = target;
                            child = source;
                            switchPort = targetPort; // Port on the switch
                        }
                    }
                    
                    if (parent && child) {
                        if (!childrenByParent[parent]) {
                            childrenByParent[parent] = [];
                        }
                        // Store child with port information
                        const childInfo = { id: child, port: switchPort, portNumber: extractPortNumber(switchPort) };
                        if (!childrenByParent[parent].find(c => c.id === child)) {
                            childrenByParent[parent].push(childInfo);
                        }
                        parentByChild[child] = parent;
                        if (switchPort) {
                            portByConnection[child] = switchPort;
                        }
                    }
                });
                
                // Identify devices by type for initial positioning
                const internetNodes = [];
                const fortigateNodes = [];
                const switchNodes = [];
                const apNodes = [];
                const clientNodes = [];
                
                nodes.forEach(node => {
                    const type = ((node.type || node.role || '') + ' ' + (node.os || '')).toLowerCase();
                    const connectionType = (node.connection_type || '').toLowerCase();
                    
                    if (type.includes('internet') || type.includes('wan')) {
                        internetNodes.push(node.id);
                    } else if (type.includes('fortigate') || type.includes('fortios') || type.includes('firewall') || type.includes('gateway')) {
                        fortigateNodes.push(node.id);
                    } else if (type.includes('fortiswitch') || (type.includes('switch') && !type.includes('ap'))) {
                        switchNodes.push(node.id);
                    } else if (type.includes('fortiap') || type.includes('ap') || type.includes('wireless') || type.includes('access_point')) {
                        apNodes.push(node.id);
                    } else if (!type.includes('fortigate') && !type.includes('switch') && !type.includes('ap')) {
                        clientNodes.push(node.id);
                    }
                });
                
                const centerX = width / 2;
                const startY = height / 10;
                
                // Layer 1: Internet (top center)
                internetNodes.forEach(nodeId => {
                    positions[nodeId] = { x: centerX, y: startY };
                });
                
                // Layer 2: Fortigate (center, below Internet)
                fortigateNodes.forEach(nodeId => {
                    positions[nodeId] = { x: centerX, y: startY + spacing.vertical };
                });
                
                // Layer 3: Switches and APs - position based on actual connections
                const xLeft = centerX - spacing.horizontal;
                const xRight = centerX + spacing.horizontal;
                
                // Group switches and APs by their connection to Fortigate
                const leftSideDevices = [];
                const rightSideDevices = [];
                
                [...switchNodes, ...apNodes].forEach(nodeId => {
                    const node = nodeMap[nodeId];
                    const type = ((node.type || node.role || '') + ' ' + (node.os || '')).toLowerCase();
                    // Switches go left, APs go right
                    if (type.includes('switch') || type.includes('meraki')) {
                        leftSideDevices.push(nodeId);
                    } else {
                        rightSideDevices.push(nodeId);
                    }
                });
                
                // Position switches on left
                leftSideDevices.forEach((nodeId, i) => {
                    const offset = (i - (leftSideDevices.length - 1) / 2) * spacing.device * 1.5;
                    positions[nodeId] = { x: xLeft + offset, y: startY + spacing.vertical * 2 };
                });
                
                // Position APs on right
                rightSideDevices.forEach((nodeId, i) => {
                    const offset = (i - (rightSideDevices.length - 1) / 2) * spacing.device * 1.5;
                    positions[nodeId] = { x: xRight + offset, y: startY + spacing.vertical * 2 };
                });
                
                // Layer 4: Clients - position below their actual parent using port information
                // Position each group of clients below their parent, sorted by port number
                Object.keys(childrenByParent).forEach(parentId => {
                    const parentPos = positions[parentId];
                    if (!parentPos) return; // Parent not positioned yet
                    
                    const children = childrenByParent[parentId];
                    // Filter to only client nodes
                    const clients = children.filter(c => clientNodes.includes(c.id));
                    
                    if (clients.length === 0) return;
                    
                    // Sort clients by port number (if available)
                    clients.sort((a, b) => {
                        if (a.portNumber !== null && b.portNumber !== null) {
                            return a.portNumber - b.portNumber;
                        }
                        if (a.portNumber !== null) return -1;
                        if (b.portNumber !== null) return 1;
                        // If no port numbers, maintain original order
                        return 0;
                    });
                    
                    // Calculate spacing - use port numbers if available, otherwise sequential
                    const hasPortNumbers = clients.some(c => c.portNumber !== null);
                    let clientSpacing;
                    let maxPosition;
                    
                    if (hasPortNumbers) {
                        // Use port numbers for positioning - map to sequential positions
                        const portNumbers = clients.map(c => c.portNumber !== null ? c.portNumber : 0);
                        const minPort = Math.min(...portNumbers.filter(p => p > 0));
                        const maxPort = Math.max(...portNumbers);
                        maxPosition = Math.max(maxPort - minPort + 1, clients.length);
                        clientSpacing = Math.min(spacing.device * 1.2, (width * 0.4) / maxPosition);
                    } else {
                        // Sequential positioning when no port numbers
                        maxPosition = Math.max(clients.length, 8);
                        clientSpacing = Math.min(spacing.device * 1.2, (width * 0.3) / maxPosition);
                    }
                    
                    clients.forEach((clientInfo, i) => {
                        const clientId = clientInfo.id;
                        let positionIndex;
                        
                        if (hasPortNumbers && clientInfo.portNumber !== null) {
                            // Use port number relative to minimum port
                            const minPort = Math.min(...clients.map(c => c.portNumber !== null ? c.portNumber : Infinity).filter(p => p !== Infinity));
                            positionIndex = clientInfo.portNumber - minPort;
                        } else {
                            // Sequential index when no port numbers
                            positionIndex = i;
                        }
                        
                        const offset = (positionIndex - (maxPosition - 1) / 2) * clientSpacing;
                        positions[clientId] = {
                            x: parentPos.x + offset,
                            y: startY + spacing.vertical * 3
                        };
                    });
                });
                
                // Handle any remaining clients without a parent
                clientNodes.forEach(clientId => {
                    if (!positions[clientId]) {
                        // Try to infer position from connection type
                        const node = nodeMap[clientId];
                        const connectionType = (node.connection_type || '').toLowerCase();
                        const hasSSID = node.ssid || false;
                        
                        if (connectionType === 'wifi' || hasSSID) {
                            // Wireless client - position on right side
                            const rightClients = clientNodes.filter(id => 
                                !positions[id] && (nodeMap[id].ssid || (nodeMap[id].connection_type || '').toLowerCase() === 'wifi')
                            );
                            const index = rightClients.indexOf(clientId);
                            const offset = (index - (rightClients.length - 1) / 2) * spacing.device;
                            positions[clientId] = { x: xRight + offset, y: startY + spacing.vertical * 3 };
                        } else {
                            // Wired client - position on left side
                            const leftClients = clientNodes.filter(id => 
                                !positions[id] && !nodeMap[id].ssid && (nodeMap[id].connection_type || '').toLowerCase() !== 'wifi'
                            );
                            const index = leftClients.indexOf(clientId);
                            const offset = (index - (leftClients.length - 1) / 2) * spacing.device;
                            positions[clientId] = { x: xLeft + offset, y: startY + spacing.vertical * 3 };
                        }
                    }
                });
                
                // Handle any remaining nodes
                nodes.forEach(node => {
                    if (!positions[node.id]) {
                        // Default position if not assigned
                        positions[node.id] = { x: centerX, y: height / 2 };
                    }
                });
                
                return positions;
            }
            
            createDevice(nodeData, x, y) {
                const config = this.deviceIcons[nodeData.type] || this.deviceIcons.default;
                
                // Create device group
                const deviceGroup = document.createElementNS(this.svgNS, 'g');
                deviceGroup.setAttribute('id', `device-${nodeData.id}`);
                deviceGroup.setAttribute('class', 'device');
                deviceGroup.setAttribute('transform', `translate(${x}, ${y})`);
                deviceGroup.style.cursor = 'pointer';
                
                // Create device circle with gradient
                const circle = document.createElementNS(this.svgNS, 'circle');
                circle.setAttribute('r', config.size / 2);
                circle.setAttribute('fill', `url(#gradient-${nodeData.type})`);
                circle.setAttribute('stroke', config.color);
                circle.setAttribute('stroke-width', '2');
                circle.setAttribute('filter', 'url(#shadow)');
                
                // Create device icon (using text for now, will be replaced with actual SVG icons)
                const iconGroup = document.createElementNS(this.svgNS, 'g');
                iconGroup.setAttribute('class', 'device-icon');
                
                // Load actual SVG icon with model-specific fallback
                const iconPath = this.getModelSpecificIcon(nodeData) || config.icon;
                this.loadSVGIcon(iconPath, iconGroup, config.size);
                
                // Create device label
                const label = document.createElementNS(this.svgNS, 'text');
                label.setAttribute('class', 'device-label');
                label.setAttribute('y', config.size / 2 + 20);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('fill', config.labelColor);
                label.setAttribute('font-size', '12');
                label.setAttribute('font-weight', 'bold');
                label.textContent = nodeData.name;
                
                // Create health indicator
                const healthIndicator = document.createElementNS(this.svgNS, 'circle');
                healthIndicator.setAttribute('class', 'health-indicator');
                healthIndicator.setAttribute('cx', config.size / 2 - 5);
                healthIndicator.setAttribute('cy', -config.size / 2 + 5);
                healthIndicator.setAttribute('r', '6');
                healthIndicator.setAttribute('fill', this.getHealthColor(nodeData.health || 'good'));
                healthIndicator.setAttribute('stroke', '#ffffff');
                healthIndicator.setAttribute('stroke-width', '2');
                
                // Add click handler
                deviceGroup.addEventListener('click', () => this.showDeviceDetails(nodeData));
                
                // Assemble device
                deviceGroup.appendChild(circle);
                deviceGroup.appendChild(iconGroup);
                deviceGroup.appendChild(label);
                deviceGroup.appendChild(healthIndicator);
                
                if (this.showHealth) {
                    deviceGroup.appendChild(healthIndicator);
                }
                
                this.topologyGroup.appendChild(deviceGroup);
                
                // Store device reference
                this.devices.set(nodeData.id, {
                    element: deviceGroup,
                    data: nodeData,
                    x: x,
                    y: y
                });
            }
            
            getModelSpecificIcon(nodeData) {
                // Check for model-specific icon first
                if (nodeData.model && this.modelSpecificIcons[nodeData.model]) {
                    return this.modelSpecificIcons[nodeData.model];
                }
                
                // Check for partial model match
                if (nodeData.model) {
                    for (const modelName in this.modelSpecificIcons) {
                        if (nodeData.model.includes(modelName)) {
                            return this.modelSpecificIcons[modelName];
                        }
                    }
                }
                
                return null; // Fallback to generic icon
            }
            
            async loadSVGIcon(iconPath, container, size) {
                try {
                    // Add cache-busting parameter
                    const cacheBuster = `?t=${Date.now()}`;
                    const response = await fetch(iconPath + cacheBuster);
                    if (response.ok) {
                        const svgText = await response.text();
                        const parser = new DOMParser();
                        const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
                        const icon = svgDoc.documentElement;
                        
                        // Scale and position the icon
                        icon.setAttribute('width', size * 0.8);
                        icon.setAttribute('height', size * 0.8);
                        icon.setAttribute('x', -size * 0.4);
                        icon.setAttribute('y', -size * 0.4);
                        icon.setAttribute('fill', '#ffffff');
                        icon.style.display = 'block';
                        icon.style.visibility = 'visible';
                        
                        // Clear any existing content
                        while (container.firstChild) {
                            container.removeChild(container.firstChild);
                        }
                        
                        container.appendChild(icon);
                        console.log(`‚úÖ Loaded SVG icon: ${iconPath}`);
                    } else {
                        console.warn(`‚ùå Failed to load SVG icon: ${iconPath} (${response.status})`);
                        this.createTextIcon(container, size);
                    }
                } catch (error) {
                    console.warn('Failed to load SVG icon:', iconPath, error);
                    this.createTextIcon(container, size);
                }
            }
            
            createTextIcon(container, size) {
                const text = document.createElementNS(this.svgNS, 'text');
                text.setAttribute('x', '0');
                text.setAttribute('y', '5');
                text.setAttribute('text-anchor', 'middle');
                text.setAttribute('fill', '#ffffff');
                text.setAttribute('font-size', size * 0.4);
                text.setAttribute('font-weight', 'bold');
                text.textContent = 'üî•';
                container.appendChild(text);
            }
            
            createConnection(fromDevice, toDevice, linkData) {
                const line = document.createElementNS(this.svgNS, 'line');
                line.setAttribute('class', 'connection');
                line.setAttribute('x1', fromDevice.x);
                line.setAttribute('y1', fromDevice.y);
                line.setAttribute('x2', toDevice.x);
                line.setAttribute('y2', toDevice.y);
                line.setAttribute('stroke', this.getConnectionColor(linkData.status || 'active'));
                line.setAttribute('stroke-width', '3');
                line.setAttribute('stroke-opacity', '0.6');
                line.setAttribute('stroke-dasharray', linkData.type === 'wireless' ? '5,5' : '0');
                
                // Add connection to background
                this.topologyGroup.insertBefore(line, this.topologyGroup.firstChild);
                
                this.connections.push({
                    element: line,
                    from: fromDevice,
                    to: toDevice,
                    data: linkData
                });
            }
            
            getHealthColor(health) {
                const colors = {
                    'good': '#4caf50',
                    'warning': '#ff9800',
                    'critical': '#f44336',
                    'offline': '#9e9e9e'
                };
                return colors[health] || colors['good'];
            }
            
            getConnectionColor(status) {
                const colors = {
                    'active': '#58a6ff',
                    'error': '#f44336',
                    'warning': '#ff9800',
                    'inactive': '#9e9e9e'
                };
                return colors[status] || colors['active'];
            }
            
            showDeviceDetails(deviceData) {
                const details = `
                    <strong>${deviceData.name}</strong><br>
                    Type: ${deviceData.type}<br>
                    IP: ${deviceData.ip || 'N/A'}<br>
                    Status: ${deviceData.status || 'Unknown'}<br>
                    Health: ${deviceData.health || 'Unknown'}
                `;
                
                // Show details in a tooltip or panel
                this.showTooltip(details);
            }
            
            showTooltip(content) {
                // Remove existing tooltip
                const existingTooltip = document.querySelector('.tooltip');
                if (existingTooltip) {
                    existingTooltip.remove();
                }
                
                // Create new tooltip
                const tooltip = document.createElement('div');
                tooltip.className = 'tooltip';
                tooltip.innerHTML = content;
                tooltip.style.cssText = `
                    position: absolute;
                    background: rgba(26, 31, 46, 0.95);
                    color: white;
                    padding: 10px;
                    border-radius: 5px;
                    border: 1px solid #30363d;
                    font-size: 12px;
                    z-index: 1000;
                    pointer-events: none;
                `;
                
                document.body.appendChild(tooltip);
                
                // Position tooltip near mouse
                document.addEventListener('mousemove', function positionTooltip(e) {
                    tooltip.style.left = e.clientX + 10 + 'px';
                    tooltip.style.top = e.clientY + 10 + 'px';
                });
                
                // Remove tooltip after 3 seconds
                setTimeout(() => {
                    tooltip.remove();
                    document.removeEventListener('mousemove', positionTooltip);
                }, 3000);
            }
            
            toggleDeviceLabels() {
                this.showLabels = !this.showLabels;
                if (this.nodeGroup) {
                    this.nodeGroup.selectAll('.node-label')
                        .style('display', this.showLabels ? 'block' : 'none');
                }
                // Re-render if we have current data
                if (this.currentData) {
                    this.renderTopology(this.currentData);
                }
            }
            
            toggleHealthStatus() {
                this.showHealth = !this.showHealth;
                // Health indicators can be added as circles or other elements
                // For now, we'll just toggle visibility if they exist
                if (this.nodeGroup) {
                    this.nodeGroup.selectAll('.health-indicator')
                        .style('display', this.showHealth ? 'block' : 'none');
                }
            }
            
            resetView() {
                // Reset zoom and pan using D3.js
                if (this.svg && this.zoom) {
                    this.svg.transition()
                        .duration(750)
                        .call(this.zoom.transform, d3.zoomIdentity);
                }
            }
            
            clearTopology() {
                // Clear existing topology
                if (this.linkGroup) this.linkGroup.selectAll('.link').remove();
                if (this.nodeGroup) this.nodeGroup.selectAll('.node').remove();
                this.devices.clear();
                this.connections = [];
            }
            
            updateStats(deviceCount, connectionCount) {
                document.getElementById('device-count').textContent = deviceCount;
                document.getElementById('connection-count').textContent = connectionCount;
                
                // Calculate overall health
                const healthStatus = this.calculateOverallHealth();
                document.getElementById('health-status').textContent = healthStatus;
                document.getElementById('health-status').style.color = this.getHealthColor(healthStatus);
            }
            
            calculateOverallHealth() {
                // Simple health calculation based on device statuses
                const devices = Array.from(this.devices.values());
                const criticalDevices = devices.filter(d => d.data.health === 'critical').length;
                const warningDevices = devices.filter(d => d.data.health === 'warning').length;
                
                if (criticalDevices > 0) return 'critical';
                if (warningDevices > 0) return 'warning';
                return 'good';
            }
            
            showError(message) {
                console.error(message);
                // Could show an error notification here
            }
            
            handleDeviceClick(e) {
                // Handle device selection
                const deviceElement = e.target.closest('.device');
                if (deviceElement) {
                    // Remove previous selection
                    const prevSelected = this.svg.querySelector('.device.selected');
                    if (prevSelected) {
                        prevSelected.classList.remove('selected');
                    }
                    
                    // Add selection to clicked device
                    deviceElement.classList.add('selected');
                }
            }
            
            handleMouseMove(e) {
                // Handle hover effects
                const deviceElement = e.target.closest('.device');
                if (deviceElement) {
                    this.svg.style.cursor = 'pointer';
                } else {
                    this.svg.style.cursor = 'default';
                }
            }
        }
        
        // Initialize the enhanced 2D topology
        let topology2D;
        
        window.addEventListener('load', function() {
            topology2D = new Enhanced2DTopology();
        });
        
        // Global functions for button clicks
        function loadFortinetTopology() {
            topology2D.loadFortinetTopology();
        }
        
        function loadDemoTopology() {
            topology2D.loadDemoTopology();
        }
        
        function toggleDeviceLabels() {
            topology2D.toggleDeviceLabels();
        }
        
        function toggleHealthStatus() {
            topology2D.toggleHealthStatus();
        }
        
        function resetView() {
            topology2D.resetView();
        }
        
        function zoomIn() {
            if (topology2D.svg && topology2D.zoom) {
                topology2D.svg.transition().call(topology2D.zoom.scaleBy, 1.5);
            }
        }
        
        function zoomOut() {
            if (topology2D.svg && topology2D.zoom) {
                topology2D.svg.transition().call(topology2D.zoom.scaleBy, 1 / 1.5);
            }
        }
        
        function resetZoom() {
            if (topology2D.svg && topology2D.zoom) {
                topology2D.svg.transition()
                    .duration(750)
                    .call(topology2D.zoom.transform, d3.zoomIdentity);
            }
        }
    </script>
</body>
</html>
