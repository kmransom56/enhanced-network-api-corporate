window.initApp = function() { if (!window.dependenciesLoaded) { console.warn('Dependencies not yet loaded, waiting...'); return; } console.log('Initializing 3D Network Topology Editor...'); const canvas = document.getElementById('topology-canvas'); if (!canvas) { console.error('Canvas element not found! Cannot initialize 3D scene.'); return; } console.log('Canvas element found, proceeding with initialization...'); window.scene = new THREE.Scene(); window.camera = new THREE.PerspectiveCamera(60, 2, 0.1, 2000); try { window.renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false, preserveDrawingBuffer: true, powerPreference: "high-performance" }); console.log('WebGL renderer created successfully'); } catch (error) { console.error('Failed to create WebGL renderer:', error); try { window.renderer = new THREE.WebGLRenderer({ canvas, antialias: false, alpha: false, preserveDrawingBuffer: true }); console.log('WebGL renderer created with fallback settings'); } catch (fallbackError) { console.error('WebGL completely failed:', fallbackError); return; } } window.renderer.setSize(canvas.clientWidth, canvas.clientHeight); window.renderer.setClearColor(0x0e1116, 1.0); window.renderer.setPixelRatio(window.devicePixelRatio); const gl = window.renderer.getContext(); if (!gl) { console.error('WebGL context not available'); return; } console.log('WebGL context verified:', gl.getParameter(gl.VERSION)); window.controls = null; window.yamlOut = document.getElementById('yaml-output'); window.meshes = {}; window.topologyNodeMeta = {}; function getFortinetIconUrl(node) { if (!node || !node.type) return null; const model = (node.model || '').toLowerCase(); if (node.type === 'fortigate') { if (model.includes('60e') || model.includes('61e') || model.includes('61f')) { return '/static/fortinet-icons/FortiGate_Series_R22_2025Q2.svg'; } return '/static/fortinet-icons/FortiGate_Series_R22_2025Q2.svg'; } if (node.type === 'fortiswitch') { if (model.includes('124') && model.includes('poe')) { return '/static/fortinet-icons/FortiSwitch_Series_R14_2025Q2.svg'; } return '/static/fortinet-icons/FortiSwitch_Series_R14_2025Q2.svg'; } if (node.type === 'fortiap') { if (model.includes('231f')) { return '/static/fortinet-icons/FortiAP_Series_R8_2025Q2.svg'; } return '/static/fortinet-icons/FortiAP_Series_R8_2025Q2.svg'; } if (node.type === 'windows') { return '/static/fortinet-icons/Windows.svg'; } if (node.type === 'android') { return '/static/fortinet-icons/Android.svg'; } if (node.type === 'apple') { return '/static/fortinet-icons/Apple.svg'; } if (node.type === 'linux') { return '/static/fortinet-icons/Linux.svg'; } if (node.type === 'gaming' || node.type === 'xbox' || node.type === 'playstation') { return '/static/fortinet-icons/Gaming.svg'; } switch (node.type) { case 'fortigate': return '/static/fortinet-icons/FortiGate.svg'; case 'fortiswitch': return '/static/fortinet-icons/FortiSwitch.svg'; case 'fortiap': return '/static/fortinet-icons/FortiAP.svg'; case 'client': return '/static/fortinet-icons/Client.svg'; default: return '/static/fortinet-icons/Client.svg'; } } function layoutHierarchical(gateways, switches, aps, meshByName, links) { const layerZ = { gateway: 60, switch: 20, ap: -20 }; const spacingX = 40; const children = {}; links.forEach(link => { if (!link.from || !link.to) return; if (!children[link.from]) children[link.from] = []; children[link.from].push(link.to); }); function layoutRow(items, z, y) { const count = items.length || 1; const totalWidth = (count - 1) * spacingX; items.forEach((item, idx) => { const mesh = meshByName[item.name]; if (!mesh) return; const x = idx * spacingX - totalWidth / 2; mesh.position.set(x, y, z); }); } layoutRow(gateways, layerZ.gateway, 8); switches.forEach((swWrap, idx) => { const swMesh = meshByName[swWrap.name]; if (!swMesh) return; let parentGw = gateways.find(gw => (children[gw.name] || []).includes(swWrap.name)); if (!parentGw) { parentGw = gateways[0]; } const parentMesh = parentGw ? meshByName[parentGw.name] : null; const baseX = parentMesh ? parentMesh.position.x : 0; const baseZ = layerZ.switch; const siblings = switches.filter(s => { return (children[parentGw.name] || []).includes(s.name); }); const indexInSiblings = siblings.findIndex(s => s.name === swWrap.name); const count = siblings.length || 1; const totalWidth = (count - 1) * spacingX; const x = baseX + (indexInSiblings >= 0 ? indexInSiblings * spacingX - totalWidth / 2 : 0); swMesh.position.set(x, 6, baseZ); }); aps.forEach(apWrap => { const apMesh = meshByName[apWrap.name]; if (!apMesh) return; let parentName = null; links.forEach(link => { if (link.to === apWrap.name && !parentName) { parentName = link.from; } }); const parentMesh = parentName ? meshByName[parentName] : null; const baseX = parentMesh ? parentMesh.position.x : 0; const baseZ = parentMesh ? parentMesh.position.z : layerZ.ap; const offsetX = (Math.random() - 0.5) * 20; const offsetZ = 10; apMesh.position.set(baseX + offsetX, 10, baseZ - offsetZ); }); } function updateDetailsPanel(mesh) { if (!detailsPanelBody || !mesh || !mesh.userData) { return; } const name = mesh.userData.name; const meta = window.topologyNodeMeta[name] || mesh.userData.topology || {}; const fields = [ ['Name', name || meta.name], ['Type', meta.type], ['IP', meta.ip], ['Model', meta.model], ['Serial', meta.serial], ['Status', meta.status], ['Connected via', meta.connected_via] ]; const html = fields .filter(([_, v]) => v !== undefined && v !== null) .map(([label, value]) => `<p><strong>${label}:</strong> ${value}</p>`) .join('') || '<p>No details available.</p>'; detailsPanelBody.innerHTML = html; } window.camera.position.set(0, 40, 50); window.scene.add(new THREE.AmbientLight(0xffffff, 0.85)); const dir = new THREE.DirectionalLight(0xffffff, 0.6); dir.position.set(50, 100, 50); window.scene.add(dir); const grid = new THREE.GridHelper(200, 100, 0x30363d, 0x20262d); window.scene.add(grid); if (THREE.OrbitControls) { window.controls = new THREE.OrbitControls(window.camera, window.renderer.domElement); window.controls.enableDamping = true; window.controls.dampingFactor = 0.1; } else { console.warn('OrbitControls not loaded, using manual camera controls'); } const raycaster = new THREE.Raycaster(); const mouse = new THREE.Vector2(); const plane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0); const planeIntersect = new THREE.Vector3(); let dragging = null; let offset = new THREE.Vector3(); const materialByType = { router: new THREE.MeshStandardMaterial({ color: 0x3fb950 }), switch: new THREE.MeshStandardMaterial({ color: 0x58a6ff }), firewall: new THREE.MeshStandardMaterial({ color: 0xf0883e }), access_point: new THREE.MeshStandardMaterial({ color: 0xbf7af0 }), server: new THREE.MeshStandardMaterial({ color: 0xff6b6b }), default: new THREE.MeshStandardMaterial({ color: 0x9e9e9e }) }; const nodeGeometry = new THREE.BoxGeometry(8, 4, 8); function resize() { const { width, height } = canvas.getBoundingClientRect(); window.renderer.setSize(width, height, false); window.camera.aspect = width/height; window.camera.updateProjectionMatrix(); } window.addEventListener('resize', resize); resize(); function animate() { requestAnimationFrame(animate); if (window.controls) window.controls.update(); window.renderer.render(window.scene, window.camera); } animate(); canvas.addEventListener('mousedown', onMouseDown); canvas.addEventListener('mousemove', onMouseMove); canvas.addEventListener('mouseup', onMouseUp); const detailsPanelBody = document.getElementById('device-details-body'); function onMouseDown(event) { event.preventDefault(); const rect = canvas.getBoundingClientRect(); mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(mouse, window.camera); const intersects = raycaster.intersectObjects(window.scene.children.filter(obj => obj.userData.draggable)); if (intersects.length > 0) { const hit = intersects[0].object; dragging = hit; if (window.controls) window.controls.enabled = false; if (raycaster.ray.intersectPlane(plane, planeIntersect)) { offset.copy(planeIntersect).sub(dragging.position); } updateDetailsPanel(hit); } } function onMouseMove(event) { if (!dragging) return; const rect = canvas.getBoundingClientRect(); mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(mouse, window.camera); if (raycaster.ray.intersectPlane(plane, planeIntersect)) { const target = new THREE.Vector3().copy(planeIntersect).sub(offset); target.x = Math.round(target.x / 5) * 5; target.z = Math.round(target.z / 5) * 5; target.y = 5; dragging.position.copy(target); updateYAML(); updateConnectionPositions(); } } function onMouseUp() { if (dragging) { if (onMouseMove.throttleTimer) { clearTimeout(onMouseMove.throttleTimer); onMouseMove.throttleTimer = null; } updateConnectionsForMesh(dragging); updateYAML(); dragging = null; if (window.controls) window.controls.enabled = true; } } document.querySelectorAll('.asset-item').forEach(item => { item.addEventListener('dragstart', ev => ev.dataTransfer.setData('device-type', ev.target.dataset.type)); }); canvas.addEventListener('dragover', ev => ev.preventDefault()); canvas.addEventListener('drop', async ev => { ev.preventDefault(); const type = ev.dataTransfer.getData('device-type'); const pos = screenToWorld(ev.clientX, ev.clientY); const name = `${type}_${Date.now()}`; const mesh = await createDeviceMesh(type, name); mesh.position.copy(pos); window.scene.add(mesh); updateYAML(); }); function screenToWorld(x, y) { const rect = canvas.getBoundingClientRect(); const nx = ((x - rect.left)/rect.width)*2 - 1; const ny = -((y - rect.top)/rect.height)*2 + 1; const vec = new THREE.Vector3(nx, ny, 0.5).unproject(window.camera); vec.x = Math.round(vec.x/10)*10; vec.y = 5; vec.z = Math.round(vec.z/10)*10; return vec; } async function createDeviceMesh(type, name = null) { if (!name) { name = generateUniqueName(type); } else { name = ensureUniqueName(name); } let mesh; try { const iconUrl = getFortinetIconUrl({ type: type }); if (iconUrl) { console.log(`Loading SVG icon for ${type}: ${iconUrl}`); mesh = await makeBillboard(iconUrl, type); } else { console.warn(`No icon found for ${type}, using geometry fallback`); mesh = await createFallbackMesh(type); } } catch (error) { console.warn(`Failed to load ${type} icon:`, error); mesh = await createFallbackMesh(type); } mesh.userData.type = type; mesh.userData.name = name; mesh.userData.draggable = true; mesh.userData.id = `${type}_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`; mesh.name = name; registerMesh(name, mesh); return mesh; } function generateUniqueName(type) { let counter = 1; let baseName = `${type}_${counter}`; while (window.meshes[baseName]) { counter++; baseName = `${type}_${counter}`; } return baseName; } function ensureUniqueName(proposedName) { if (!window.meshes[proposedName]) { return proposedName; } let counter = 1; let uniqueName = `${proposedName}_${counter}`; while (window.meshes[uniqueName]) { counter++; uniqueName = `${proposedName}_${counter}`; } return uniqueName; } function registerMesh(name, mesh) { if (window.meshes[name]) { console.warn(`Mesh name collision detected: ${name}. Removing old mesh.`); const oldMesh = window.meshes[name]; window.scene.remove(oldMesh); disposeMesh(oldMesh); } window.meshes[name] = mesh; console.log(`Registered mesh: ${name} (${mesh.userData.type})`); } function unregisterMesh(name) { if (window.meshes[name]) { delete window.meshes[name]; console.log(`Unregistered mesh: ${name}`); } } async function createFallbackMesh(type) { const material = materialByType[type] || materialByType.default; const geometry = getGeometryForType(type); return new THREE.Mesh(geometry, material.clone()); } async function loadGlbMesh(_url, type) { try { const material = materialByType[type] || materialByType.default; const geometry = getGeometryForType(type); const mesh = new THREE.Mesh(geometry, material.clone()); mesh.material.emissive = new THREE.Color(material.color).multiplyScalar(0.1); return mesh; } catch (error) { console.warn('GLB loading failed, using fallback:', error); const material = materialByType[type] || materialByType.default; return new THREE.Mesh(nodeGeometry, material.clone()); } } function getGeometryForType(type) { switch (type) { case 'router': return new THREE.BoxGeometry(12, 4, 8); case 'switch': return new THREE.BoxGeometry(16, 2, 8); case 'firewall': return new THREE.BoxGeometry(10, 6, 10); case 'access_point': return new THREE.CylinderGeometry(4, 4, 2, 8); case 'server': return new THREE.BoxGeometry(8, 16, 12); default: return nodeGeometry; } } async function makeBillboard(url, type) { try { if (url.endsWith('.svg')) { const img = new Image(); img.crossOrigin = 'Anonymous'; await new Promise((resolve, reject) => { img.onload = resolve; img.onerror = reject; img.src = url; }); const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d'); canvas.width = 256; canvas.height = 256; ctx.drawImage(img, 0, 0, canvas.width, canvas.height); const tex = new THREE.CanvasTexture(canvas); tex.needsUpdate = true; const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true, side: THREE.DoubleSide }); const geo = new THREE.PlaneGeometry(30, 20); const mesh = new THREE.Mesh(geo, mat); mesh.onBeforeRender = (_, __, camera) => mesh.quaternion.copy(camera.quaternion); console.log(`Successfully created SVG billboard for ${type}`); return mesh; } else { const tex = await new THREE.TextureLoader().loadAsync(url); const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true }); const geo = new THREE.PlaneGeometry(30, 20); const mesh = new THREE.Mesh(geo, mat); mesh.onBeforeRender = (_, __, camera) => mesh.quaternion.copy(camera.quaternion); return mesh; } } catch (error) { console.warn('Billboard loading failed, using geometry fallback:', error); const material = materialByType[type] || materialByType.default; return new THREE.Mesh(nodeGeometry, material.clone()); } } function updateYAML() { const nodes = window.scene.children .filter(o => o.position && o.userData.type) .map(o => ({ name: o.userData.name || o.userData.type, type: o.userData.type, position: { x: Math.round(o.position.x * 100) / 100, y: Math.round(o.position.y * 100) / 100, z: Math.round(o.position.z * 100) / 100 } })); const topology = { nodes: nodes, connections: extractConnections() }; const yamlString = generateYAMLString(topology); if (window.yamlOut) window.yamlOut.value = yamlString; if (window.autoSaveEnabled) { saveTopologyToBackend(topology); } } function generateYAMLString(topology) { let yaml = 'topology:\n'; yaml += '  nodes:\n'; topology.nodes.forEach(node => { yaml += `    - name: ${node.name}\n`; yaml += `      type: ${node.type}\n`; yaml += `      position:\n`; yaml += `        x: ${node.position.x}\n`; yaml += `        y: ${node.position.y}\n`; yaml += `        z: ${node.position.z}\n`; }); if (topology.connections && topology.connections.length > 0) { yaml += '  connections:\n'; topology.connections.forEach(conn => { yaml += `    - from: ${conn.from}\n`; yaml += `      to: ${conn.to}\n`; if (conn.type) yaml += `      type: ${conn.type}\n`; }); } return yaml; } function extractConnections() { return []; } async function parseYAMLToScene(yamlString) { try { let topology; if (window.jsyaml) { try { const parsed = jsyaml.load(yamlString, { schema: jsyaml.SAFE_SCHEMA, json: true }); topology = validateAndNormalizeTopology(parsed); } catch (yamlError) { console.warn('js-yaml parsing failed, falling back to custom parser:', yamlError); topology = parseYAMLString(yamlString); } } else { console.warn('js-yaml library not loaded, using custom parser'); topology = parseYAMLString(yamlString); } await loadTopologyIntoScene(topology); } catch (error) { console.error('YAML parsing error:', error); alert('Failed to parse YAML: ' + error.message); } } function validateAndNormalizeTopology(parsed) { if (!parsed || typeof parsed !== 'object') { throw new Error('Invalid YAML: must be an object'); } let topology = parsed; if (parsed.topology) { topology = parsed.topology; } if (!topology.nodes) { topology.nodes = []; } if (!Array.isArray(topology.nodes)) { throw new Error('Nodes must be an array'); } if (!topology.connections) { topology.connections = []; } if (!Array.isArray(topology.connections)) { throw new Error('Connections must be an array'); } topology.nodes = topology.nodes.map((node, index) => { if (!node || typeof node !== 'object') { throw new Error(`Node at index ${index} must be an object`); } if (!node.type) { throw new Error(`Node at index ${index} is missing required 'type' field`); } if (!node.name) { node.name = `${node.type}_${index + 1}`; } if (node.position) { node.position = { x: parseFloat(node.position.x) || 0, y: parseFloat(node.position.y) || 5, z: parseFloat(node.position.z) || 0 }; } return node; }); topology.connections = topology.connections.filter((conn, index) => { if (!conn || typeof conn !== 'object') { console.warn(`Skipping invalid connection at index ${index}`); return false; } if (!conn.from || !conn.to) { console.warn(`Skipping connection at index ${index}: missing from/to`); return false; } return true; }); return topology; } function parseYAMLString(yamlString) { try { console.warn('Using fallback YAML parser - consider loading js-yaml library for better compatibility'); const lines = yamlString.split('\n').map(line => line.replace(/\r$/, '')); const topology = { nodes: [], connections: [] }; let currentSection = null; let currentNode = null; let currentConnection = null; let _baseIndent = null; for (let i = 0; i < lines.length; i++) { const line = lines[i]; const trimmed = line.trim(); if (!trimmed || trimmed.startsWith('#')) continue; const leadingWhitespace = line.match(/^(\s*)/); const indent = leadingWhitespace ? leadingWhitespace[1].length : 0; try { if (trimmed.startsWith('topology:')) { _baseIndent = indent; continue; } else if (trimmed.startsWith('nodes:')) { currentSection = 'nodes'; currentNode = null; currentConnection = null; } else if (trimmed.startsWith('connections:')) { currentSection = 'connections'; currentNode = null; currentConnection = null; } else if (trimmed.startsWith('- ')) { if (currentSection === 'nodes') { currentNode = {}; topology.nodes.push(currentNode); } else if (currentSection === 'connections') { currentConnection = {}; topology.connections.push(currentConnection); } const itemContent = trimmed.substring(2).trim(); if (itemContent && itemContent.includes(':')) { const colonIndex = itemContent.indexOf(':'); const key = itemContent.substring(0, colonIndex).trim(); const value = itemContent.substring(colonIndex + 1).trim(); if (currentNode && currentSection === 'nodes') { currentNode[key] = parseYAMLValue(value); } else if (currentConnection && currentSection === 'connections') { currentConnection[key] = parseYAMLValue(value); } } } else if (trimmed.includes(':')) { const colonIndex = trimmed.indexOf(':'); const key = trimmed.substring(0, colonIndex).trim(); const value = trimmed.substring(colonIndex + 1).trim(); if (currentSection === 'nodes' && currentNode) { if (key === 'position') { currentNode.position = {}; } else if (currentNode.position && ['x', 'y', 'z'].includes(key)) { const numValue = parseFloat(value); currentNode.position[key] = isNaN(numValue) ? 0 : numValue; } else { currentNode[key] = parseYAMLValue(value); } } else if (currentSection === 'connections' && currentConnection) { currentConnection[key] = parseYAMLValue(value); } } } catch (lineError) { console.warn(`Error parsing YAML line ${i + 1}: "${line}"`, lineError); continue; } } return validateAndNormalizeTopology({ topology }); } catch (error) { console.error('Fallback YAML parsing failed:', error); throw new Error(`YAML parsing failed: ${error.message}`); } } function parseYAMLValue(value) { if (!value || value === '') return null; const unquoted = value.replace(/^["']|["']$/g, ''); if (unquoted.toLowerCase() === 'true') return true; if (unquoted.toLowerCase() === 'false') return false; if (unquoted.toLowerCase() === 'null' || unquoted.toLowerCase() === '~') return null; const num = parseFloat(unquoted); if (!isNaN(num) && isFinite(num)) return num; return unquoted; } async function loadTopologyIntoScene(topology) { clearScene(); for (const nodeData of topology.nodes) { const mesh = await createDeviceMesh(nodeData.type, nodeData.name); if (nodeData.position) { mesh.position.set( nodeData.position.x || 0, nodeData.position.y || 5, nodeData.position.z || 0 ); } else { const index = topology.nodes.indexOf(nodeData); mesh.position.set( (index % 5) * 20 - 40, 5, Math.floor(index / 5) * 20 - 40 ); } window.scene.add(mesh); } if (topology.connections) { topology.connections.forEach(conn => { createConnection(conn.from, conn.to, conn.type); }); } updateYAML(); } const btnLoadFortinet = document.getElementById('btn-load-fortinet-topology'); if (btnLoadFortinet) { btnLoadFortinet.addEventListener('click', () => { loadFortinetTopologyScene(); }); } function frameSceneToMeshes(meshByName) { const names = Object.keys(meshByName || {}); if (!names.length) return; const box = new THREE.Box3(); names.forEach(name => { const m = meshByName[name]; if (m) { box.expandByObject(m); } }); const size = box.getSize(new THREE.Vector3()); const center = box.getCenter(new THREE.Vector3()); const maxDim = Math.max(size.x, size.y, size.z) || 10; const distance = maxDim * 3; window.camera.position.set(center.x + distance, center.y + distance, center.z + distance); window.camera.lookAt(center); if (window.controls) { window.controls.target.copy(center); window.controls.update(); } } async function loadFortinetTopologyScene() { try { const resp = await fetch('/api/topology/scene'); if (!resp.ok) { throw new Error(`HTTP ${resp.status}`); } const data = await resp.json(); clearScene(); const nodesData = data.nodes || []; const linksData = data.links || []; Object.keys(window.topologyNodeMeta).forEach(k => delete window.topologyNodeMeta[k]); nodesData.forEach((n, idx) => { const name = n.id || n.name || `node_${idx}`; window.topologyNodeMeta[name] = n; }); const typeMap = { fortigate: 'firewall', fortiswitch: 'switch', fortiap: 'access_point' }; const gateways = []; const switches = []; const aps = []; Object.entries(window.topologyNodeMeta).forEach(([name, n]) => { if (n.type === 'fortigate') gateways.push({ name, node: n }); else if (n.type === 'fortiswitch') switches.push({ name, node: n }); else if (n.type === 'fortiap') aps.push({ name, node: n }); }); const meshByName = {}; async function createFortinetMesh(name, n) { const devType = typeMap[n.type] || 'router'; const iconUrl = getFortinetIconUrl(n); let mesh; if (iconUrl) { mesh = await makeBillboard(iconUrl, devType); mesh.userData.type = devType; mesh.userData.name = name; mesh.userData.draggable = true; mesh.userData.id = name; mesh.name = name; registerMesh(name, mesh); } else { mesh = await createDeviceMesh(devType, name); } mesh.userData.topology = n; window.scene.add(mesh); meshByName[name] = mesh; return mesh; } for (const { name, node } of gateways) { await createFortinetMesh(name, node); } for (const { name, node } of switches) { await createFortinetMesh(name, node); } for (const { name, node } of aps) { await createFortinetMesh(name, node); } layoutHierarchical(gateways, switches, aps, meshByName, linksData); frameSceneToMeshes(meshByName); linksData.forEach(link => { const from = link.from; const to = link.to; const linkType = link.type || 'ethernet'; if (from && to) { createConnection(from, to, linkType); } }); updateYAML(); } catch (err) { console.error('Failed to load Fortinet topology scene:', err); alert('Failed to load Fortinet topology from /api/topology/scene'); } } function clearScene() { const objectsToRemove = window.scene.children.filter(obj => obj.userData.type || obj.userData.connection ); objectsToRemove.forEach(obj => { window.scene.remove(obj); disposeMesh(obj); }); Object.keys(window.meshes).forEach(key => { unregisterMesh(key); }); console.log('Scene cleared successfully'); } function disposeMesh(mesh) { if (mesh.geometry) { mesh.geometry.dispose(); } if (mesh.material) { if (Array.isArray(mesh.material)) { mesh.material.forEach(mat => mat.dispose()); } else { mesh.material.dispose(); } } if (mesh.material && mesh.material.map) { mesh.material.map.dispose(); } } function createConnection(fromName, toName, connectionType = 'ethernet') { try { const fromMesh = meshes[fromName]; const toMesh = meshes[toName]; if (!fromMesh) { console.warn(`Cannot create connection: source mesh '${fromName}' not found`); console.log('Available meshes:', Object.keys(meshes)); return null; } if (!toMesh) { console.warn(`Cannot create connection: target mesh '${toName}' not found`); console.log('Available meshes:', Object.keys(meshes)); return null; } removeConnection(fromName, toName); const points = [ fromMesh.position.clone(), toMesh.position.clone() ]; const geometry = new THREE.BufferGeometry().setFromPoints(points); const material = new THREE.LineBasicMaterial({ color: getConnectionColor(connectionType), linewidth: 2 }); const line = new THREE.Line(geometry, material); line.userData.connection = { from: fromName, to: toName, type: connectionType, id: `${fromName}_to_${toName}` }; line.name = `connection_${fromName}_to_${toName}`; scene.add(line); console.log(`Created connection: ${fromName} -> ${toName} (${connectionType})`); return line; } catch (error) { console.error(`Failed to create connection ${fromName} -> ${toName}:`, error); return null; } } function removeConnection(fromName, toName) { const connectionsToRemove = scene.children.filter(obj => obj.userData.connection && ((obj.userData.connection.from === fromName && obj.userData.connection.to === toName) || (obj.userData.connection.from === toName && obj.userData.connection.to === fromName)) ); connectionsToRemove.forEach(connection => { scene.remove(connection); disposeMesh(connection); }); } function updateConnectionPositions() { const connections = scene.children.filter(obj => obj.userData.connection); connections.forEach(connection => { updateSingleConnection(connection); }); } function updateConnectionsForMesh(mesh) { if (!mesh.userData.name) return; const meshName = mesh.userData.name; const connections = scene.children.filter(obj => obj.userData.connection && (obj.userData.connection.from === meshName || obj.userData.connection.to === meshName) ); connections.forEach(connection => { updateSingleConnection(connection); }); } function updateSingleConnection(connection) { const { from, to } = connection.userData.connection; const fromMesh = meshes[from]; const toMesh = meshes[to]; if (fromMesh && toMesh) { const fromPoint = calculateConnectionPoint(fromMesh, toMesh); const toPoint = calculateConnectionPoint(toMesh, fromMesh); const points = [fromPoint, toPoint]; const positions = connection.geometry.attributes.position; if (positions) { positions.setXYZ(0, fromPoint.x, fromPoint.y, fromPoint.z); positions.setXYZ(1, toPoint.x, toPoint.y, toPoint.z); positions.needsUpdate = true; } else { connection.geometry.dispose(); connection.geometry = new THREE.BufferGeometry().setFromPoints(points); } } else { console.warn(`Connection ${from} -> ${to} has missing mesh references`); } } function calculateConnectionPoint(fromMesh, toMesh) { const fromPos = fromMesh.position.clone(); const toPos = toMesh.position.clone(); const direction = new THREE.Vector3().subVectors(toPos, fromPos).normalize(); const box = new THREE.Box3().setFromObject(fromMesh); const size = box.getSize(new THREE.Vector3()); const maxDimension = Math.max(size.x, size.z) / 2; return fromPos.clone().add(direction.multiplyScalar(maxDimension + 1)); } function getConnectionColor(type) { const colorMap = { ethernet: 0x00ff00, fiber: 0xff6600, wireless: 0x0088ff, management: 0xff0088, default: 0xffffff }; return colorMap[type] || colorMap.default; } async function saveTopologyToBackend(topology) { try { const response = await fetch('/api/topology/save', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(topology) }); if (!response.ok) { console.warn('Failed to save topology to backend'); } } catch (error) { console.warn('Error saving topology:', error); } } document.querySelectorAll('.status-chip').forEach(chip => { chip.addEventListener('click', () => { document.querySelectorAll('.status-chip').forEach(c=>c.classList.remove('active')); chip.classList.add('active'); }); }); const btnGeneratePdf = document.getElementById('btn-generate-pdf'); if (btnGeneratePdf) { btnGeneratePdf.addEventListener('click', async () => { const html = document.documentElement.outerHTML; const resp = await fetch('/api/pdf/generate', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify({ jobId: 'JOB-'+Date.now(), html }) }); if (!resp.ok) return alert('PDF failed'); const blob = await resp.blob(); download(blob, 'install-pack.pdf'); captureThumbnail(); }); } const btnImportVisio = document.getElementById('btn-import-visio'); if (btnImportVisio) { btnImportVisio.addEventListener('click', () => { const inp = document.createElement('input'); inp.type = 'file'; inp.accept = '.vsdx'; inp.onchange = async e => { const file = e.target.files[0]; const form = new FormData(); form.append('file', file); const r = await fetch('/api/visio/import', { method:'POST', body: form }); const json = await r.json(); if (json.success) { for (const n of json.nodes) { const mesh = await createDeviceMesh(n.type, n.name || `visio_${json.nodes.indexOf(n)}`); mesh.position.set(n.position[0], n.position[1], n.position[2]); scene.add(mesh); } updateYAML(); } }; inp.click(); }); } const btnImportYaml = document.getElementById('btn-import-yaml'); if (btnImportYaml) { btnImportYaml.addEventListener('click', () => { const inp = document.createElement('input'); inp.type = 'file'; inp.accept = '.yaml,.yml'; inp.onchange = async e => { const file = e.target.files[0]; const yamlContent = await file.text(); await parseYAMLToScene(yamlContent); }; inp.click(); }); } const btnExportYaml = document.getElementById('btn-export-yaml'); if (btnExportYaml) { btnExportYaml.addEventListener('click', () => { const yamlContent = window.yamlOut?.value || generateYAMLString({ nodes: window.scene.children .filter(o => o.position && o.userData.type) .map(o => ({ name: o.userData.name || o.userData.type, type: o.userData.type, position: { x: Math.round(o.position.x * 100) / 100, y: Math.round(o.position.y * 100) / 100, z: Math.round(o.position.z * 100) / 100 } })), connections: [] }); const blob = new Blob([yamlContent], { type: 'text/yaml' }); download(blob, `topology_${new Date().toISOString().split('T')[0]}.yaml`); }); } const btnLoadYamlFromInput = document.getElementById('btn-load-yaml'); if (btnLoadYamlFromInput && window.yamlOut) { btnLoadYamlFromInput.addEventListener('click', async () => { const yamlContent = window.yamlOut.value; if (yamlContent.trim()) { await parseYAMLToScene(yamlContent); } else { alert('Please enter YAML content first'); } }); } const btnClearScene = document.getElementById('btn-clear-scene'); if (btnClearScene) { btnClearScene.addEventListener('click', () => { if (confirm('Clear all devices from the scene?')) { clearScene(); updateYAML(); } }); } const btnAutoLayout = document.getElementById('btn-auto-layout'); if (btnAutoLayout) { btnAutoLayout.addEventListener('click', () => { autoLayoutDevices(); }); } function autoLayoutDevices() { const devices = window.scene.children.filter(obj => obj.userData.type); const gridSize = Math.ceil(Math.sqrt(devices.length)); const spacing = 25; devices.forEach((device, index) => { const row = Math.floor(index / gridSize); const col = index % gridSize; const x = (col - gridSize / 2) * spacing; const z = (row - gridSize / 2) * spacing; device.position.set(x, 5, z); }); updateYAML(); } window.autoLayoutDevices = autoLayoutDevices; function download(blob, name) { const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = name; a.click(); setTimeout(()=>URL.revokeObjectURL(url),1000); } function captureThumbnail() { const data = canvas.toDataURL('image/jpeg', 0.8); document.getElementById('thumb-img').src = data; } window.createDeviceMesh = createDeviceMesh; window.updateYAML = updateYAML; window.clearScene = clearScene; window.autoLayoutDevices = autoLayoutDevices; window.loadFortinetTopologyScene = async function() { console.log('Loading Fortinet topology scene...'); try { const response = await fetch('/api/topology/scene'); const data = await response.json(); console.log('Topology scene data:', data); if (data.nodes && data.links) { clearScene(); const devices = []; data.nodes.forEach(node => { const device = { name: node.name || node.id, type: node.type || 'unknown', role: node.role || 'device', ip: node.ip || '', model: node.model || '', status: node.status || 'unknown', metadata: node.metadata || {} }; devices.push(device); }); await Promise.all(devices.map(async device => { const mesh = await createDeviceMesh(device.type, device.name); if (device.position) { mesh.position.set(device.position.x, device.position.y, device.position.z); } window.scene.add(mesh); return mesh; })); const devicesInScene = window.scene.children.filter(obj => obj.userData.type); devicesInScene.forEach((device, index) => { const x = (index % 3 - 1) * 35; const z = -20; const y = 5; device.position.set(x, y, z); }); updateYAML(); console.log(`âœ… Loaded ${devices.length} devices into scene`); } else { console.warn('Invalid topology data format:', data); } } catch (error) { console.error('Failed to load Fortinet topology scene:', error); } }; }; document.addEventListener('DOMContentLoaded', () => { if (window.dependenciesLoaded) { window.initApp(); } });