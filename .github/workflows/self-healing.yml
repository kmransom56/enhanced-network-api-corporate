name: Self-Healing Health Monitor

on:
  schedule:
    # Run every 5 minutes for continuous monitoring
    - cron: '*/5 * * * *'
  workflow_dispatch:
  push:
    paths:
      - '.github/workflows/self-healing.yml'
      - 'src/enhanced_network_api/**'
      - 'tests/self_healing/**'

env:
  API_BASE_URL: 'http://localhost:11111'
  SLACK_WEBHOOK: ''
  HEALTH_CHECK_TIMEOUT: 30

jobs:
  health-check:
    name: System Health Check
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
        cache: 'pip'
    
    - name: Install dependencies
      run: |
        pip install requests aiohttp pytest pytest-asyncio
    
    - name: Run health checks
      run: |
        python << 'EOF'
        import asyncio
        import aiohttp
        import json
        import time
        import os
        from datetime import datetime
        
        # Get configuration from environment
        api_base_url = os.environ.get('API_BASE_URL', 'http://localhost:11111')
        
        class HealthMonitor:
            def __init__(self, base_url):
                self.base_url = base_url
                self.results = {}
            
            async def check_endpoint(self, session, endpoint, name, timeout=30):
                """Check a specific endpoint health."""
                start_time = time.time()
                try:
                    async with session.get(f"{self.base_url}{endpoint}", timeout=timeout) as response:
                        response_time = (time.time() - start_time) * 1000
                        content = await response.text()
                        
                        self.results[name] = {
                            "status": "healthy" if response.status == 200 else "unhealthy",
                            "response_time": response_time,
                            "status_code": response.status,
                            "content_length": len(content),
                            "timestamp": datetime.utcnow().isoformat()
                        }
                        
                        if response.status != 200:
                            print(f"âŒ {name}: HTTP {response.status}")
                            return False
                        else:
                            print(f"âœ… {name}: {response_time:.0f}ms")
                            return True
                            
                except asyncio.TimeoutError:
                    self.results[name] = {
                        "status": "timeout",
                        "response_time": timeout * 1000,
                        "error": "Request timeout",
                        "timestamp": datetime.utcnow().isoformat()
                    }
                    print(f"â° {name}: Timeout after {timeout}s")
                    return False
                    
                except Exception as e:
                    self.results[name] = {
                        "status": "error",
                        "error": str(e),
                        "timestamp": datetime.utcnow().isoformat()
                    }
                    print(f"âŒ {name}: {str(e)}")
                    return False
            
            async def check_topology_endpoints(self, session):
                """Check topology-specific endpoints."""
                topology_endpoints = [
                    ("/", "Main Page"),
                    ("/api/topology/raw", "Raw Topology"),
                    ("/api/topology/scene", "3D Scene"),
                    ("/docs", "API Docs"),
                    ("/health", "Health Check")
                ]
                
                tasks = []
                for endpoint, name in topology_endpoints:
                    tasks.append(self.check_endpoint(session, endpoint, name))
                
                results = await asyncio.gather(*tasks, return_exceptions=True)
                return all(result is True for result in results)
            
            async def check_mcp_bridge(self, session):
                """Check MCP bridge health."""
                try:
                    # Check if MCP bridge is accessible
                    bridge_url = "http://127.0.0.1:9001/mcp/call-tool"
                    payload = {"name": "discover_fortinet_topology", "arguments": {}}
                    
                    start_time = time.time()
                    async with session.post(bridge_url, json=payload, timeout=30) as response:
                        response_time = (time.time() - start_time) * 1000
                        
                        if response.status == 200:
                            data = await response.json()
                            self.results["mcp_bridge"] = {
                                "status": "healthy",
                                "response_time": response_time,
                                "has_content": bool(data.get("content")),
                                "is_error": data.get("isError", False),
                                "timestamp": datetime.utcnow().isoformat()
                            }
                            print(f"âœ… MCP Bridge: {response_time:.0f}ms")
                            return True
                        else:
                            self.results["mcp_bridge"] = {
                                "status": "unhealthy",
                                "response_time": response_time,
                                "status_code": response.status,
                                "timestamp": datetime.utcnow().isoformat()
                            }
                            print(f"âŒ MCP Bridge: HTTP {response.status}")
                            return False
                            
                except Exception as e:
                    self.results["mcp_bridge"] = {
                        "status": "error",
                        "error": str(e),
                        "timestamp": datetime.utcnow().isoformat()
                    }
                    print(f"âŒ MCP Bridge: {str(e)}")
                    return False
            
            async def check_data_integrity(self, session):
                """Check topology data integrity."""
                try:
                    async with session.get(f"{self.base_url}/api/topology/raw", timeout=30) as response:
                        if response.status == 200:
                            data = await response.json()
                            
                            # Validate data structure
                            required_keys = ["gateways", "switches", "aps", "clients", "links"]
                            missing_keys = [key for key in required_keys if key not in data]
                            
                            if missing_keys:
                                self.results["data_integrity"] = {
                                    "status": "invalid",
                                    "missing_keys": missing_keys,
                                    "timestamp": datetime.utcnow().isoformat()
                                }
                                print(f"âŒ Data Integrity: Missing keys {missing_keys}")
                                return False
                            
                            # Check for invalid data
                            invalid_gateways = [gw for gw in data.get("gateways", []) if not gw.get("id")]
                            invalid_switches = [sw for sw in data.get("switches", []) if not sw.get("id")]
                            
                            if invalid_gateways or invalid_switches:
                                self.results["data_integrity"] = {
                                    "status": "invalid",
                                    "invalid_gateways": len(invalid_gateways),
                                    "invalid_switches": len(invalid_switches),
                                    "timestamp": datetime.utcnow().isoformat()
                                }
                                print(f"âŒ Data Integrity: Invalid devices found")
                                return False
                            
                            self.results["data_integrity"] = {
                                "status": "valid",
                                "gateway_count": len(data.get("gateways", [])),
                                "switch_count": len(data.get("switches", [])),
                                "ap_count": len(data.get("aps", [])),
                                "client_count": len(data.get("clients", [])),
                                "link_count": len(data.get("links", [])),
                                "timestamp": datetime.utcnow().isoformat()
                            }
                            print(f"âœ… Data Integrity: All data valid")
                            return True
                        else:
                            return False
                            
                except Exception as e:
                    self.results["data_integrity"] = {
                        "status": "error",
                        "error": str(e),
                        "timestamp": datetime.utcnow().isoformat()
                    }
                    print(f"âŒ Data Integrity: {str(e)}")
                    return False
            
            async def run_all_checks(self):
                """Run all health checks."""
                print("ðŸ” Starting Enhanced Network API Health Check...")
                print(f"ðŸ“… {datetime.utcnow().isoformat()}")
                print("=" * 60)
                
                async with aiohttp.ClientSession() as session:
                    # Run all checks
                    api_healthy = await self.check_topology_endpoints(session)
                    mcp_healthy = await self.check_mcp_bridge(session)
                    data_healthy = await self.check_data_integrity(session)
                    
                    print("=" * 60)
                    
                    # Overall health status
                    overall_healthy = api_healthy and mcp_healthy and data_healthy
                    
                    if overall_healthy:
                        print("ðŸŽ‰ All systems healthy!")
                    else:
                        print("âš ï¸  Some systems need attention!")
                    
                    # Print summary
                    print(f"\nðŸ“Š Health Summary:")
                    print(f"   API Endpoints: {'âœ…' if api_healthy else 'âŒ'}")
                    print(f"   MCP Bridge: {'âœ…' if mcp_healthy else 'âŒ'}")
                    print(f"   Data Integrity: {'âœ…' if data_healthy else 'âŒ'}")
                    
                    # Save results for notification
                    self.results["overall"] = {
                        "status": "healthy" if overall_healthy else "unhealthy",
                        "api_healthy": api_healthy,
                        "mcp_healthy": mcp_healthy,
                        "data_healthy": data_healthy,
                        "timestamp": datetime.utcnow().isoformat()
                    }
                    
                    return overall_healthy
        
        # Run the health monitor
        async def main():
            monitor = HealthMonitor(api_base_url)
            healthy = await monitor.run_all_checks()
            
            # Save results to file
            with open("health_results.json", "w") as f:
                json.dump(monitor.results, f, indent=2)
            
            # Exit with appropriate code
            exit(0 if healthy else 1)
        
        asyncio.run(main())
        EOF
    
    - name: Upload health results
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: health-results-${{ github.run_number }}
        path: health_results.json
        retention-days: 7
    
    - name: Send Slack notification on failure
      if: failure()
      run: |
        # Check if Slack webhook is available
        if [ -n "$SLACK_WEBHOOK" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"ðŸš¨ Enhanced Network API Health Check Failed!\n\nðŸ“Š Results: '"$(cat health_results.json | jq -r '.overall.status' 2>/dev/null || echo 'unknown')"'\nðŸ”— Check: '"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"'"}' \
            "$SLACK_WEBHOOK"
        else
          echo "Slack webhook not configured, skipping notification"
        fi
      env:
        SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
    
    - name: Send Slack notification on recovery
      if: success() && github.event_name == 'schedule'
      run: |
        # Check if Slack webhook is available
        if [ -n "$SLACK_WEBHOOK" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"âœ… All systems healthy!"}' \
            "$SLACK_WEBHOOK"
        else
          echo "Slack webhook not configured, skipping notification"
        fi
      env:
        SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}

  auto-recovery:
    name: Auto-Recovery
    runs-on: ubuntu-latest
    needs: health-check
    if: failure() && github.event_name == 'schedule'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        pip install requests docker
    
    - name: Attempt service recovery
      run: |
        python << 'EOF'
        import requests
        import json
        import time
        from datetime import datetime
        
        class AutoRecovery:
            def __init__(self):
                self.recovery_actions = []
            
            def restart_api_service(self):
                """Restart the API service."""
                try:
                    print("ðŸ”„ Attempting to restart API service...")
                    # This would be implemented based on your deployment method
                    # For Docker: docker-compose restart api
                    # For Kubernetes: kubectl rollout restart deployment/api
                    self.recovery_actions.append("API service restart attempted")
                    return True
                except Exception as e:
                    print(f"âŒ Failed to restart API service: {e}")
                    return False
            
            def restart_mcp_bridge(self):
                """Restart the MCP bridge."""
                try:
                    print("ðŸ”„ Attempting to restart MCP bridge...")
                    # Restart MCP bridge service
                    self.recovery_actions.append("MCP bridge restart attempted")
                    return True
                except Exception as e:
                    print(f"âŒ Failed to restart MCP bridge: {e}")
                    return False
            
            def clear_cache(self):
                """Clear application cache."""
                try:
                    print("ðŸ§¹ Attempting to clear cache...")
                    # Clear Redis cache, file cache, etc.
                    self.recovery_actions.append("Cache cleared")
                    return True
                except Exception as e:
                    print(f"âŒ Failed to clear cache: {e}")
                    return False
            
            def validate_recovery(self):
                """Validate that recovery was successful."""
                try:
                    print("âœ… Validating recovery...")
                    # Check if services are responsive again
                    response = requests.get("${{ env.API_BASE_URL }}/health", timeout=30)
                    if response.status_code == 200:
                        print("âœ… Recovery successful!")
                        return True
                    else:
                        print(f"âŒ Recovery validation failed: HTTP {response.status_code}")
                        return False
                except Exception as e:
                    print(f"âŒ Recovery validation failed: {e}")
                    return False
            
            def run_recovery_sequence(self):
                """Run the complete recovery sequence."""
                print("ðŸš‘ Starting Auto-Recovery Sequence...")
                print(f"ðŸ“… {datetime.utcnow().isoformat()}")
                print("=" * 50)
                
                # Step 1: Clear cache
                if self.clear_cache():
                    time.sleep(5)
                
                # Step 2: Restart MCP bridge
                if self.restart_mcp_bridge():
                    time.sleep(10)
                
                # Step 3: Restart API service
                if self.restart_api_service():
                    time.sleep(15)
                
                # Step 4: Validate recovery
                if self.validate_recovery():
                    print("ðŸŽ‰ Auto-Recovery Successful!")
                    return True
                else:
                    print("âŒ Auto-Recovery Failed!")
                    return False
        
        # Run auto-recovery
        recovery = AutoRecovery()
        success = recovery.run_recovery_sequence()
        
        # Save recovery log
        with open("recovery_log.json", "w") as f:
            json.dump({
                "timestamp": datetime.utcnow().isoformat(),
                "actions": recovery.recovery_actions,
                "success": success
            }, f, indent=2)
        
        exit(0 if success else 1)
        EOF
    
    - name: Upload recovery log
      if: always()
      uses: actions/upload-artifact@v3
      with:
        name: recovery-log-${{ github.run_number }}
        path: recovery_log.json
        retention-days: 7
    
    - name: Send recovery notification
      if: success()
      run: |
        # Check if Slack webhook is available
        if [ -n "$SLACK_WEBHOOK" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"ðŸš‘ Auto-Recovery Successful!\n\nâœ… Services have been restored automatically.\nðŸ”— Check: '"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"'"}' \
            "$SLACK_WEBHOOK"
        else
          echo "Slack webhook not configured, skipping notification"
        fi
      env:
        SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
    
    - name: Escalate to human
      if: failure()
      run: |
        # Check if Slack webhook is available
        if [ -n "$SLACK_WEBHOOK" ]; then
          curl -X POST -H 'Content-type: application/json' \
            --data '{"text":"ðŸš¨ Auto-Recovery Failed!\n\nðŸš‘ Automatic recovery attempts failed.\nðŸ‘¨â€ðŸ’» Manual intervention required.\nðŸ”— Check: '"${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"'"}' \
            "$SLACK_WEBHOOK"
        else
          echo "Slack webhook not configured, skipping notification"
        fi
      env:
        SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
