<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IconLab - Restaurant Technology Device Recognition</title>
    <style>
        :root {
            --color-background: #fcfcf9;
            --color-surface: #fffffd;
            --color-text: #134252;
            --color-text-secondary: #626c71;
            --color-primary: #21808d;
            --color-primary-hover: #1d7480;
            --color-border: rgba(94, 82, 64, 0.2);
            --color-success: #21808d;
            --color-error: #c0152f;
            --color-warning: #a84b2f;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --color-background: #1f2121;
                --color-surface: #262828;
                --color-text: #f5f5f5;
                --color-text-secondary: rgba(167, 169, 169, 0.7);
                --color-primary: #32b8c6;
                --color-primary-hover: #2da6b2;
                --color-border: rgba(119, 124, 124, 0.3);
                --color-error: #ff5459;
                --color-warning: #e68161;
            }
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: var(--color-background);
            color: var(--color-text);
            padding: 20px;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        h1 {
            font-size: 32px;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .subtitle {
            color: var(--color-text-secondary);
            margin-bottom: 30px;
            font-size: 16px;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--color-border);
            overflow-x: auto;
        }

        .tab-btn {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: var(--color-text-secondary);
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            border-bottom: 3px solid transparent;
            transition: all 0.2s;
            white-space: nowrap;
        }

        .tab-btn:hover {
            color: var(--color-text);
            background: rgba(var(--color-primary), 0.05);
        }

        .tab-btn.active {
            color: var(--color-primary);
            border-bottom-color: var(--color-primary);
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s;
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .method-card {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
        }

        .method-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .method-title {
            font-size: 20px;
            font-weight: 600;
        }

        .method-badge {
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 500;
        }

        .badge-recommended { background: rgba(33, 128, 141, 0.15); color: var(--color-success); }
        .badge-advanced { background: rgba(168, 75, 47, 0.15); color: var(--color-warning); }
        .badge-experimental { background: rgba(192, 21, 47, 0.15); color: var(--color-error); }

        .method-description {
            color: var(--color-text-secondary);
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .code-block {
            background: var(--color-background);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 16px;
            margin: 16px 0;
            font-family: 'Courier New', monospace;
            font-size: 13px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .btn {
            padding: 10px 20px;
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: background 0.2s;
        }

        .btn:hover {
            background: var(--color-primary-hover);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn-secondary {
            background: transparent;
            border: 1px solid var(--color-border);
            color: var(--color-text);
        }

        .btn-secondary:hover {
            background: rgba(var(--color-primary), 0.1);
        }

        .demo-area {
            background: var(--color-background);
            border: 2px dashed var(--color-border);
            border-radius: 8px;
            padding: 24px;
            margin: 16px 0;
            min-height: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            gap: 16px;
        }

        .input-group {
            margin: 16px 0;
        }

        .input-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 14px;
        }

        .input-group input,
        .input-group select,
        .input-group textarea {
            width: 100%;
            padding: 10px 12px;
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            color: var(--color-text);
            font-size: 14px;
        }

        .input-group textarea {
            min-height: 100px;
            font-family: 'Courier New', monospace;
        }

        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-top: 16px;
        }

        .pros, .cons {
            padding: 16px;
            border-radius: 8px;
        }

        .pros {
            background: rgba(33, 128, 141, 0.1);
            border: 1px solid rgba(33, 128, 141, 0.2);
        }

        .cons {
            background: rgba(192, 21, 47, 0.1);
            border: 1px solid rgba(192, 21, 47, 0.2);
        }

        .pros h4, .cons h4 {
            margin-bottom: 8px;
            font-size: 14px;
        }

        .pros ul, .cons ul {
            list-style-position: inside;
            font-size: 13px;
            color: var(--color-text-secondary);
        }

        .result-display {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 20px;
            margin-top: 16px;
        }

        .status-message {
            padding: 12px;
            border-radius: 6px;
            margin: 10px 0;
            font-size: 14px;
        }

        .status-success {
            background: rgba(33, 128, 141, 0.15);
            color: var(--color-success);
            border: 1px solid rgba(33, 128, 141, 0.25);
        }

        .status-error {
            background: rgba(192, 21, 47, 0.15);
            color: var(--color-error);
            border: 1px solid rgba(192, 21, 47, 0.25);
        }

        .status-warning {
            background: rgba(168, 75, 47, 0.15);
            color: var(--color-warning);
            border: 1px solid rgba(168, 75, 47, 0.25);
        }

        .grid-2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .grid-2, .pros-cons {
                grid-template-columns: 1fr;
            }
        }

        .icon-preview {
            max-width: 200px;
            max-height: 200px;
            border: 1px solid var(--color-border);
            border-radius: 4px;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }

        .comparison-table th,
        .comparison-table td {
            padding: 12px;
            text-align: left;
            border-bottom: 1px solid var(--color-border);
        }

        .comparison-table th {
            font-weight: 600;
            background: var(--color-background);
        }

        .comparison-table tr:hover {
            background: rgba(var(--color-primary), 0.05);
        }

        .metric {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 500;
        }

        .metric-high { background: rgba(33, 128, 141, 0.15); color: var(--color-success); }
        .metric-medium { background: rgba(168, 75, 47, 0.15); color: var(--color-warning); }
        .metric-low { background: rgba(192, 21, 47, 0.15); color: var(--color-error); }
        
        .device-sample {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 8px;
            padding: 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .device-sample:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-color: var(--color-primary);
        }
        
        .result-box {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: 6px;
            padding: 16px;
            margin-top: 16px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }
        
        .device-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }
        
        .status-message {
            padding: 12px;
            border-radius: 6px;
            margin: 8px 0;
        }
        
        .status-success {
            background: rgba(33, 128, 141, 0.1);
            border: 1px solid rgba(33, 128, 141, 0.2);
            color: var(--color-success);
        }
        
        .status-info {
            background: rgba(33, 128, 141, 0.1);
            border: 1px solid rgba(33, 128, 141, 0.2);
            color: var(--color-primary);
        }
        
        .device-icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }
        
        .device-mac {
            font-family: monospace;
            font-size: 12px;
            margin: 4px 0;
        }
        
        .device-desc {
            font-size: 12px;
            color: var(--color-text-secondary);
            margin: 4px 0;
        }
        
        .section-header {
            margin-bottom: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üçΩÔ∏è IconLab - Restaurant Technology Device Recognition</h1>
        <p class="subtitle">MAC address lookup, POS system identification, and 3D model matching for restaurant technology devices</p>

        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab('device-lookup')">üîç Device Lookup</button>
            <button class="tab-btn" onclick="switchTab('pos-systems')">üõí POS Systems</button>
            <button class="tab-btn" onclick="switchTab('icon-extraction')">üì¶ Icon Extraction</button>
            <button class="tab-btn" onclick="switchTab('3d-models')">üéÆ 3D Models</button>
            <button class="tab-btn" onclick="switchTab('topology')">üìä Network Topology</button>
        </div>

        <!-- DEVICE LOOKUP -->
        <div id="device-lookup" class="tab-content active">
            <h2 class="section-header">üîç Restaurant Device Lookup</h2>

            <!-- MAC Address Lookup -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">MAC Address Device Recognition</h3>
                    <span class="method-badge badge-recommended">Live API</span>
                </div>
                <p class="method-description">
                    Lookup restaurant technology devices by MAC address using macaddress.io API and local OUI database.
                </p>

                <div class="input-group">
                    <label for="mac-input">MAC Address:</label>
                    <input type="text" id="mac-input" placeholder="00:0C:F1:12:34:56" value="00:0C:F1:12:34:56">
                </div>

                <div class="input-group">
                    <label for="hostname-input">Hostname (optional):</label>
                    <input type="text" id="hostname-input" placeholder="Clover-Station-01" value="Clover-Station-01">
                </div>

                <button class="test-btn" onclick="lookupDevice()">üîç Lookup Device</button>
                
                <div id="device-result" class="result-box" style="display: none;"></div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Features</h4>
                        <ul>
                            <li>Real-time macaddress.io API integration</li>
                            <li>Restaurant POS system detection</li>
                            <li>3D model path assignment</li>
                            <li>Confidence scoring</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ö†Ô∏è Limitations</h4>
                        <ul>
                            <li>Requires API key for detailed lookups</li>
                            <li>Limited to known OUI patterns</li>
                            <li>Some devices use random MACs</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Sample Restaurant Devices -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Sample Restaurant Devices</h3>
                    <span class="method-badge badge-advanced">Demo Data</span>
                </div>
                <p class="method-description">
                    Click on any device type to see MAC address patterns and 3D model assignments.
                </p>

                <div class="device-grid">
                    <div class="device-sample" onclick="testDevice('00:0C:F1:12:34:56', 'Clover-Station-01')">
                        <div class="device-icon">üõí</div>
                        <h4>Clover POS Register</h4>
                        <p class="device-mac">00:0C:F1</p>
                        <p class="device-desc">Ingenico OUI</p>
                    </div>
                    <div class="device-sample" onclick="testDevice('AC:BC:32:AB:CD:EF', 'Square-Terminal-01')">
                        <div class="device-icon">üí≥</div>
                        <h4>Square Terminal</h4>
                        <p class="device-mac">AC:BC:32</p>
                        <p class="device-desc">Square OUI</p>
                    </div>
                    <div class="device-sample" onclick="testDevice('B8:27:EB:98:76:54', 'Toast-KDS-01')">
                        <div class="device-icon">üñ•Ô∏è</div>
                        <h4>Toast Kitchen Display</h4>
                        <p class="device-mac">B8:27:EB</p>
                        <p class="device-desc">Raspberry Pi</p>
                    </div>
                    <div class="device-sample" onclick="testDevice('28:CF:E9:12:34:56', 'iPad-Table-01')">
                        <div class="device-icon">üì±</div>
                        <h4>iPad POS Tablet</h4>
                        <p class="device-mac">28:CF:E9</p>
                        <p class="device-desc">Apple OUI</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- ICON EXTRACTION -->
        <div id="icon-extraction" class="tab-content">
            <h2 class="section-header">üì¶ Icon Extraction from Visio Files</h2>

            <!-- Method 1: VSDX Library -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Method 1: Python VSDX Library (Recommended)</h3>
                    <span class="method-badge badge-recommended">Free & Open Source</span>
                </div>
                <p class="method-description">
                    Extract shapes directly from Visio stencil files using the vsdx Python library.
                </p>

                <div class="input-group">
                    <label for="vsdx-installation">Installation:</label>
                    <textarea id="vsdx-installation" readonly>pip install vsdx</textarea>
                </div>

                <div class="input-group">
                    <label for="vsdx-extraction">Extract Shapes Code:</label>
                    <textarea id="vsdx-extraction" readonly>from vsdx import VisioFile

# Open Fortinet or Meraki Visio stencil
with VisioFile('Fortinet_Visio_Stencil.vssx') as vis:
    # Access first page (stencil master page)
    page = vis.pages[0]
    
    # Get all master shapes
    all_shapes = page.all_shapes
    
    for shape in all_shapes:
        shape_name = shape.text
        shape_id = shape.ID
        
        # Extract shape geometry data
        print(f"Shape: {shape_name}, ID: {shape_id}")
        
        # Get shape properties
        if hasattr(shape, 'data_properties'):
            for prop in shape.data_properties:
                print(f"  Property: {prop.label} = {prop.value}")</textarea>
                </div>

                <button class="test-btn" onclick="copyCode('vsdx-extraction')">üìã Copy Code</button>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>Free and open source</li>
                            <li>Direct access to shape data</li>
                            <li>Python native integration</li>
                            <li>Works with VSSX stencil files</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ö†Ô∏è Cons</h4>
                        <ul>
                            <li>Limited to basic shape properties</li>
                            <li>May not handle complex geometry</li>
                            <li>Requires manual SVG export</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Method 2: Aspose.Diagram -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Method 2: Aspose.Diagram (Commercial)</h3>
                    <span class="method-badge badge-advanced">Full-Featured</span>
                </div>
                <p class="method-description">
                    Commercial library with comprehensive Visio manipulation and export capabilities.
                </p>

                <div class="input-group">
                    <label for="aspose-extraction">Aspose.Diagram Code:</label>
                    <textarea id="aspose-extraction" readonly>import aspose.diagram as diagram

# Load Visio stencil
visio_file = diagram.Diagram("Fortinet_Stencil.vssx")

# Access master shapes
masters = visio_file.masters

for master in masters:
    master_name = master.name
    master_id = master.id
    
    # Extract shape data
    for shape in master.shapes:
        # Get shape geometry
        geometry = shape.geoms
        
        # Extract path data for 2D outline
        for geom in geometry:
            move_to = geom.moveTo
            line_to = geom.lineTo
            # Process path commands

# Export individual icon as image
shape = visio_file.pages[0].shapes[0]

# Save as PNG with transparent background
shape_stream = shape.to_image("PNG")

# Or export to SVG (vector format)
shape.to_svg("fortigate_icon.svg")</textarea>
                </div>

                <button class="test-btn" onclick="copyCode('aspose-extraction')">üìã Copy Code</button>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>Full Visio format support</li>
                            <li>Built-in SVG/PNG export</li>
                            <li>Commercial support available</li>
                            <li>Handles complex geometry</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ö†Ô∏è Cons</h4>
                        <ul>
                            <li>Commercial license required</li>
                            <li>Heavier dependency</li>
                            <li>More complex API</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- 3D Conversion Workflow -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">SVG to 3D Extrusion Workflow</h3>
                    <span class="method-badge badge-experimental">Blender Automation</span>
                </div>
                <p class="method-description">
                    Convert extracted SVG icons to true 3D models using Blender automation.
                </p>

                <div class="input-group">
                    <label for="blender-script">Blender Python Script:</label>
                    <textarea id="blender-script" readonly>import bpy
import os

# Clear existing objects
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete()

# Import SVG
bpy.ops.import_curve.svg(filepath="device_icon.svg")

# Convert curves to mesh
for obj in bpy.context.selected_objects:
    if obj.type == 'CURVE':
        bpy.context.view_layer.objects.active = obj
        # Convert to mesh
        bpy.ops.object.convert(target='MESH')
        
        # Add Solidify modifier for 3D depth
        solidify = obj.modifiers.new(name="Solidify", type='SOLIDIFY')
        solidify.thickness = 0.05  # Adjust depth
        
        # Apply modifier
        bpy.ops.object.modifier_apply(modifier="Solidify")

# Export as OBJ or STL
bpy.ops.export_scene.obj(filepath="device_3d_model.obj")
# Or STL for 3D printing
bpy.ops.export_mesh.stl(filepath="device_3d_model.stl")</textarea>
                </div>

                <button class="test-btn" onclick="copyCode('blender-script')">üìã Copy Blender Script</button>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Benefits</h4>
                        <ul>
                            <li>True 3D models from 2D icons</li>
                            <li>Automated batch processing</li>
                            <li>Customizable extrusion depth</li>
                            <li>Multiple export formats (OBJ, STL)</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ö†Ô∏è Requirements</h4>
                        <ul>
                            <li>Blender software required</li>
                            <li>Python scripting knowledge</li>
                            <li>Processing time for large batches</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Online API Method -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Image-to-3D Online API</h3>
                    <span class="method-badge badge-advanced">Cloud Processing</span>
                </div>
                <p class="method-description">
                    Use online services to convert icon images to 3D models automatically.
                </p>

                <div class="input-group">
                    <label for="api-conversion">Python API Integration:</label>
                    <textarea id="api-conversion" readonly>import requests

def convert_image_to_3d(image_path, output_path):
    # Example using hypothetical API
    files = {'file': open(image_path, 'rb')}
    params = {
        'extrude_depth': 10,
        'quality': 'high',
        'format': 'obj'
    }
    
    response = requests.post(
        'https://api.imagetostl.com/convert',
        files=files,
        data=params
    )
    
    with open(output_path, 'wb') as f:
        f.write(response.content)

# Usage
convert_image_to_3d('fortinet_icon.png', 'fortinet_3d.obj')</textarea>
                </div>

                <button class="test-btn" onclick="copyCode('api-conversion')">üìã Copy API Code</button>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Advantages</h4>
                        <ul>
                            <li>No local software required</li>
                            <li>Fast processing</li>
                            <li>Multiple format support</li>
                            <li>Cloud-based scaling</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ö†Ô∏è Considerations</h4>
                        <ul>
                            <li>API costs may apply</li>
                            <li>Internet connection required</li>
                            <li>File size limitations</li>
                            <li>Privacy concerns</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

                <div class="input-group">
                    <label for="vendor-select">Select Vendor</label>
                    <select id="vendor-select" aria-label="Select vendor for icon lookup">
                        <option value="fortinet">Fortinet (icons.fortinet.com)</option>
                        <option value="cisco">Cisco SAFE Icon Library</option>
                        <option value="meraki">Meraki Dashboard</option>
                        <option value="aruba">Aruba Networks</option>
                    </select>
                </div>

                <div class="input-group">
                    <label>Device Model</label>
                    <input type="text" id="device-model" placeholder="e.g., FortiGate-60F, Meraki MS120">
                </div>

                <button class="btn" onclick="findVendorIcon()">üîç Find Icon</button>

                <div id="vendor-result" class="demo-area" style="display: none;">
                    <p>Icon URL will appear here</p>
                </div>

                <div class="code-block">// JavaScript Implementation
async function findVendorIcon(vendor, model) {
    const vendorAPIs = {
        fortinet: 'https://icons.fortinet.com/api/search',
        cisco: 'https://www.cisco.com/c/dam/en/us/products/se/2022/icons',
        meraki: 'https://documentation.meraki.com/api/icons'
    };
    
    const response = await fetch(`${vendorAPIs[vendor]}?model=${model}`);
    const data = await response.json();
    return data.iconUrl;
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>Official, brand-accurate icons</li>
                            <li>Regularly updated</li>
                            <li>Multiple formats (PNG, SVG)</li>
                            <li>Consistent styling</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons</h4>
                        <ul>
                            <li>Vendor-specific APIs</li>
                            <li>May require authentication</li>
                            <li>Rate limiting</li>
                            <li>Inconsistent API structures</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Method 2: MAC OUI Mapping -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Method 2: MAC Address OUI-Based Mapping</h3>
                    <span class="method-badge badge-recommended">Recommended</span>
                </div>
                <p class="method-description">
                    Automatically identify vendor from MAC address and map to icon repository.
                </p>

                <div class="input-group">
                    <label>MAC Address</label>
                    <input type="text" id="mac-address" placeholder="00:09:0F:AA:BB:CC">
                </div>

                <button class="btn" onclick="findByMAC()">üîç Identify & Find Icon</button>

                <div id="mac-result" class="demo-area" style="display: none;">
                    <div id="mac-vendor-info"></div>
                </div>

                <div class="code-block">// JavaScript Implementation
async function findIconByMAC(macAddress) {
    // Extract OUI (first 3 octets)
    const oui = macAddress.replace(/[:-]/g, '').substring(0, 6).toUpperCase();
    
    // Query OUI database
    const response = await fetch(`https://api.macvendors.com/${oui}`);
    const vendor = await response.text();
    
    // Map vendor to icon repository
    const iconMap = {
        'Fortinet': 'fortinet-icons',
        'Cisco': 'cisco-icons',
        'Meraki': 'meraki-icons'
    };
    
    const iconRepo = iconMap[vendor] || 'generic-icons';
    
    // Additional device info from SNMP/LLDP
    const deviceModel = await getSNMPSysDescr(macAddress);
    
    return {
        vendor,
        model: deviceModel,
        iconUrl: `https://icons.${iconRepo}.com/${deviceModel}.svg`
    };
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>Fully automated</li>
                            <li>Works with network discovery</li>
                            <li>No manual device entry</li>
                            <li>Integrates with SNMP/LLDP/CDP</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons</h4>
                        <ul>
                            <li>Requires network access</li>
                            <li>OUI database maintenance</li>
                            <li>Generic icons for unknown models</li>
                            <li>May need SNMP community strings</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Method 3: Visio Stencil Extraction -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Method 3: Extract from Visio Stencils</h3>
                    <span class="method-badge badge-advanced">Advanced</span>
                </div>
                <p class="method-description">
                    Parse .vsdx files (ZIP archives) to extract vector icon data directly from vendor stencils.
                </p>

                <div class="input-group">
                    <label>Upload Visio Stencil (.vsdx)</label>
                    <input type="file" id="visio-file" accept=".vsdx">
                </div>

                <button class="btn" onclick="extractVisioIcons()">üì¶ Extract Icons</button>

                <div id="visio-result" class="demo-area" style="display: none;">
                    <div id="visio-icons"></div>
                </div>

                <div class="code-block">// JavaScript Implementation (Node.js)
const JSZip = require('jszip');
const fs = require('fs');
const xml2js = require('xml2js');

async function extractVisioIcons(vsdxPath) {
    const data = fs.readFileSync(vsdxPath);
    const zip = await JSZip.loadAsync(data);
    
    // Visio files contain XML definitions
    const shapeXML = await zip.file('visio/masters/masters.xml').async('text');
    const parser = new xml2js.Parser();
    const result = await parser.parseStringPromise(shapeXML);
    
    // Extract shape paths
    const shapes = result.Masters.Master.map(master => ({
        name: master.$.Name,
        id: master.$.ID,
        pathData: extractPathData(master)
    }));
    
    // Convert to SVG
    return shapes.map(shape => ({
        name: shape.name,
        svg: convertVisioPathToSVG(shape.pathData)
    }));
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>Vector data directly from source</li>
                            <li>Official vendor stencils</li>
                            <li>High quality icons</li>
                            <li>One-time extraction</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons</h4>
                        <ul>
                            <li>Complex XML parsing</li>
                            <li>Visio format knowledge required</li>
                            <li>Manual stencil downloads</li>
                            <li>Path conversion needed</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Method 4: Web Scraping -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Method 4: Vendor Documentation Scraping</h3>
                    <span class="method-badge badge-advanced">Advanced</span>
                </div>
                <p class="method-description">
                    Extract icons from vendor documentation pages and product websites.
                </p>

                <div class="input-group">
                    <label>Vendor Documentation URL</label>
                    <input type="text" id="scrape-url" placeholder="https://docs.fortinet.com/products">
                </div>

                <button class="btn" onclick="scrapeVendorDocs()">üï∑Ô∏è Scrape Icons</button>

                <div id="scrape-result" class="demo-area" style="display: none;">
                    <div id="scraped-icons"></div>
                </div>

                <div class="code-block">// JavaScript Implementation (Node.js with Puppeteer)
const puppeteer = require('puppeteer');

async function scrapeVendorIcons(url) {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    await page.goto(url);
    
    // Extract all image elements
    const icons = await page.evaluate(() => {
        const images = Array.from(document.querySelectorAll('img[src*="icon"], img[alt*="device"]'));
        return images.map(img => ({
            src: img.src,
            alt: img.alt,
            width: img.width,
            height: img.height
        }));
    });
    
    // Download and categorize
    for (const icon of icons) {
        const response = await page.goto(icon.src);
        const buffer = await response.buffer();
        fs.writeFileSync(`./icons/${icon.alt}.png`, buffer);
    }
    
    await browser.close();
    return icons;
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>Access to latest icons</li>
                            <li>Specific product images</li>
                            <li>Can capture 3D renders</li>
                            <li>No API dependency</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons</h4>
                        <ul>
                            <li>May violate ToS</li>
                            <li>Fragile (breaks with site changes)</li>
                            <li>Image quality varies</li>
                            <li>Requires manual categorization</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Method 5: Generic Icon Sets -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Method 5: Generic Network Icon Sets</h3>
                    <span class="method-badge badge-recommended">Fallback</span>
                </div>
                <p class="method-description">
                    Use open-source or generic icon libraries with device type classification.
                </p>

                <div class="input-group">
                    <label>Device Type</label>
                    <select id="device-type">
                        <option value="router">Router</option>
                        <option value="switch">Switch</option>
                        <option value="firewall">Firewall</option>
                        <option value="ap">Access Point</option>
                        <option value="server">Server</option>
                    </select>
                </div>

                <button class="btn" onclick="getGenericIcon()">üé® Get Generic Icon</button>

                <div id="generic-result" class="demo-area" style="display: none;">
                    <div id="generic-icon"></div>
                </div>

                <div class="code-block">// JavaScript Implementation
const genericIconSets = {
    'font-awesome': 'https://fontawesome.com/icons/',
    'material-design': 'https://fonts.google.com/icons',
    'network-icons': 'https://github.com/network-icons/svg'
};

function getGenericIcon(deviceType) {
    const iconMap = {
        'router': 'üîÄ',
        'switch': 'üîå',
        'firewall': 'üõ°Ô∏è',
        'ap': 'üì°',
        'server': 'üñ•Ô∏è'
    };
    
    // For production, use actual SVG files
    return {
        svg: `<svg><!-- Generic ${deviceType} icon --></svg>`,
        emoji: iconMap[deviceType],
        fallback: true
    };
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>Always available</li>
                            <li>Consistent styling</li>
                            <li>Open source/free</li>
                            <li>Simple implementation</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons</h4>
                        <ul>
                            <li>Not brand-specific</li>
                            <li>Generic appearance</li>
                            <li>Limited model differentiation</li>
                            <li>May need customization</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- SVG CONVERSION METHODS -->
        <div id="svg-conversion" class="tab-content">
            <h2 style="margin-bottom: 20px;">SVG Conversion Methods</h2>

            <!-- Method 1: Potrace -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Method 1: Potrace Command-Line Tracing</h3>
                    <span class="method-badge badge-recommended">Recommended</span>
                </div>
                <p class="method-description">
                    Use Potrace for high-quality bitmap to vector conversion with full control.
                </p>

                <div class="input-group">
                    <label>Upload PNG Image</label>
                    <input type="file" id="potrace-input" accept="image/png,image/jpg">
                </div>

                <div class="input-group">
                    <label>Threshold (0-255)</label>
                    <input type="range" id="potrace-threshold" min="0" max="255" value="128">
                    <span id="threshold-value">128</span>
                </div>

                <button class="btn" onclick="convertWithPotrace()">üîÑ Convert to SVG</button>

                <div id="potrace-result" class="demo-area" style="display: none;">
                    <div id="potrace-output"></div>
                </div>

                <div class="code-block">// Node.js Implementation
const potrace = require('potrace');
const fs = require('fs');

function convertWithPotrace(imagePath, options = {}) {
    const params = {
        background: '#FFFFFF',
        color: '#000000',
        threshold: options.threshold || 128,
        turnPolicy: potrace.Potrace.TURNPOLICY_MINORITY,
        turdSize: 2,
        optCurve: true,
        optTolerance: 0.2
    };
    
    return new Promise((resolve, reject) => {
        potrace.trace(imagePath, params, (err, svg) => {
            if (err) reject(err);
            else resolve(svg);
        });
    });
}

// Usage
const svg = await convertWithPotrace('device-icon.png', { threshold: 128 });
fs.writeFileSync('device-icon.svg', svg);</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>Excellent trace quality</li>
                            <li>Highly configurable</li>
                            <li>Command-line automation</li>
                            <li>Free and open source</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons</h4>
                        <ul>
                            <li>Requires system dependencies</li>
                            <li>Learning curve for parameters</li>
                            <li>Not real-time suitable</li>
                            <li>Black/white only (posterize for color)</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Method 2: Inkscape CLI -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Method 2: Inkscape Command-Line</h3>
                    <span class="method-badge badge-recommended">Recommended</span>
                </div>
                <p class="method-description">
                    Leverage Inkscape's powerful tracing engine via CLI for superior results.
                </p>

                <div class="input-group">
                    <label>Trace Mode</label>
                    <select id="inkscape-mode">
                        <option value="brightness">Brightness</option>
                        <option value="edge">Edge Detection</option>
                        <option value="multicolor">Multicolor</option>
                        <option value="autotrace">Autotrace</option>
                    </select>
                </div>

                <button class="btn" onclick="convertWithInkscape()">üé® Convert with Inkscape</button>

                <div id="inkscape-result" class="demo-area" style="display: none;">
                    <p>Inkscape conversion result will appear here</p>
                </div>

                <div class="code-block">// Node.js Implementation with child_process
const { exec } = require('child_process');
const util = require('util');
const execPromise = util.promisify(exec);

async function convertWithInkscape(inputPath, outputPath, mode = 'brightness') {
    // Modern Inkscape syntax (1.0+)
    const command = `inkscape "${inputPath}" --export-type="svg" --export-filename="${outputPath}"`;
    
    try {
        const { stdout, stderr } = await execPromise(command);
        console.log('Conversion complete:', stdout);
        return outputPath;
    } catch (error) {
        console.error('Inkscape error:', error);
        throw error;
    }
}

// For tracing (converting raster to vector)
async function traceWithInkscape(inputPath, outputPath) {
    // Use Inkscape's trace bitmap feature
    const command = `inkscape "${inputPath}" --verb=SelectionTrace --verb=FileSave --verb=FileQuit`;
    await execPromise(command);
    return outputPath;
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>Professional-grade results</li>
                            <li>Multiple trace algorithms</li>
                            <li>Color support</li>
                            <li>Industry standard tool</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons</h4>
                        <ul>
                            <li>Large dependency (Inkscape install)</li>
                            <li>Slower than Potrace</li>
                            <li>Heavier resource usage</li>
                            <li>Version compatibility issues</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Method 3: Cloud API -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Method 3: Cloudinary Vectorize API</h3>
                    <span class="method-badge badge-recommended">Cloud-Based</span>
                </div>
                <p class="method-description">
                    Use Cloudinary's vectorize transformation for instant cloud-based conversion.
                </p>

                <div class="input-group">
                    <label>Cloudinary Cloud Name</label>
                    <input type="text" id="cloud-name" placeholder="your-cloud-name">
                </div>

                <div class="input-group">
                    <label>Detail Level (1-1000)</label>
                    <input type="range" id="vectorize-detail" min="1" max="1000" value="300">
                    <span id="detail-value">300</span>
                </div>

                <div class="input-group">
                    <label>Colors (1-30)</label>
                    <input type="range" id="vectorize-colors" min="1" max="30" value="10">
                    <span id="colors-value">10</span>
                </div>

                <button class="btn" onclick="convertWithCloudinary()">‚òÅÔ∏è Vectorize</button>

                <div id="cloudinary-result" class="demo-area" style="display: none;">
                    <div id="cloudinary-output"></div>
                </div>

                <div class="code-block">// JavaScript Implementation
const cloudinary = require('cloudinary').v2;

// Configure
cloudinary.config({
    cloud_name: 'your-cloud-name',
    api_key: 'your-api-key',
    api_secret: 'your-api-secret'
});

// Upload and vectorize
async function vectorizeWithCloudinary(imagePath, options = {}) {
    const uploadResult = await cloudinary.uploader.upload(imagePath, {
        public_id: 'device-icon',
        resource_type: 'image'
    });
    
    // Generate vectorized URL
    const vectorizedUrl = cloudinary.url(uploadResult.public_id, {
        effect: `vectorize:detail:${options.detail || 300}:colors:${options.colors || 10}`,
        format: 'svg'
    });
    
    return {
        originalUrl: uploadResult.secure_url,
        vectorizedUrl: vectorizedUrl
    };
}

// Client-side usage
const vectorUrl = `https://res.cloudinary.com/demo/image/upload/e_vectorize:colors:10:detail:300/device-icon.svg`;</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>No local dependencies</li>
                            <li>Fast and scalable</li>
                            <li>CDN delivery</li>
                            <li>Real-time URL transformations</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons</h4>
                        <ul>
                            <li>Requires paid account</li>
                            <li>Bandwidth costs</li>
                            <li>Less control over algorithm</li>
                            <li>Internet dependency</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Method 4: svg-path-parser -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Method 4: SVG Path Parser (Programmatic)</h3>
                    <span class="method-badge badge-advanced">Advanced</span>
                </div>
                <p class="method-description">
                    Parse and manipulate SVG paths programmatically with JavaScript libraries.
                </p>

                <div class="input-group">
                    <label>SVG Path Data</label>
                    <textarea id="svg-path-input" placeholder="M10,10 L50,10 L50,50 L10,50 Z"></textarea>
                </div>

                <button class="btn" onclick="parseSVGPath()">üîç Parse & Normalize</button>

                <div id="parser-result" class="demo-area" style="display: none;">
                    <div id="parsed-output"></div>
                </div>

                <div class="code-block">// JavaScript Implementation
const { parseSVG, makeAbsolute } = require('svg-path-parser');

function normalizeSVGPath(pathString) {
    // Parse SVG path
    const commands = parseSVG(pathString);
    
    // Convert all to absolute coordinates
    const absolute = makeAbsolute(commands);
    
    // Extract points for Babylon.js
    const points = [];
    absolute.forEach(cmd => {
        if (cmd.x !== undefined && cmd.y !== undefined) {
            points.push({ x: cmd.x, y: cmd.y, z: 0 });
        }
    });
    
    return {
        commands: absolute,
        points: points,
        boundingBox: calculateBoundingBox(points)
    };
}

// Convert canvas drawing to SVG path
function canvasToSVGPath(canvas) {
    const ctx = canvas.getContext('2d');
    const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
    
    // Edge detection and path tracing
    const paths = tracePaths(imageData);
    return paths.map(p => `M${p.join('L')}Z`).join(' ');
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>Full programmatic control</li>
                            <li>Path manipulation/optimization</li>
                            <li>Client-side processing</li>
                            <li>No external dependencies</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons</h4>
                        <ul>
                            <li>Requires existing SVG data</li>
                            <li>No raster-to-vector conversion</li>
                            <li>Complex for bezier curves</li>
                            <li>Manual path creation tedious</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Method 5: Visio Extraction -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Method 5: Extract SVG from Visio Stencils</h3>
                    <span class="method-badge badge-advanced">Advanced</span>
                </div>
                <p class="method-description">
                    Extract already-vectorized data from Visio .vsdx files (which are already in XML/vector format).
                </p>

                <div class="code-block">// Node.js Implementation
const JSZip = require('jszip');
const xml2js = require('xml2js');
const fs = require('fs');

async function extractSVGFromVisio(vsdxPath) {
    const data = fs.readFileSync(vsdxPath);
    const zip = await JSZip.loadAsync(data);
    
    // Read shape masters
    const mastersXML = await zip.file('visio/masters/masters.xml').async('text');
    const parser = new xml2js.Parser();
    const masters = await parser.parseStringPromise(mastersXML);
    
    const svgs = [];
    
    for (const master of masters.Masters.Master) {
        // Read individual shape XML
        const shapeFile = `visio/masters/master${master.$.ID}.xml`;
        const shapeXML = await zip.file(shapeFile).async('text');
        const shape = await parser.parseStringPromise(shapeXML);
        
        // Extract geometry (paths)
        const geometry = extractGeometry(shape);
        
        // Convert to SVG
        const svg = convertVisioGeometryToSVG(geometry, {
            name: master.$.Name,
            width: parseFloat(master.$.Width),
            height: parseFloat(master.$.Height)
        });
        
        svgs.push({
            name: master.$.Name,
            svg: svg
        });
    }
    
    return svgs;
}

function convertVisioGeometryToSVG(geometry, metadata) {
    let pathData = '';
    
    geometry.forEach(section => {
        section.Row.forEach(row => {
            if (row.$.T === 'MoveTo') {
                pathData += `M${row.Cell[0].$.V},${row.Cell[1].$.V} `;
            } else if (row.$.T === 'LineTo') {
                pathData += `L${row.Cell[0].$.V},${row.Cell[1].$.V} `;
            }
        });
    });
    
    return `<svg width="${metadata.width}" height="${metadata.height}">
        <path d="${pathData}" fill="black"/>
    </svg>`;
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>Already vector format</li>
                            <li>High quality official icons</li>
                            <li>No quality loss</li>
                            <li>Batch extraction possible</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons</h4>
                        <ul>
                            <li>Complex XML parsing</li>
                            <li>Visio format knowledge required</li>
                            <li>Coordinate system conversion</li>
                            <li>Manual stencil acquisition</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- 3D RENDERING METHODS -->
        <div id="3d-rendering" class="tab-content">
            <h2 style="margin-bottom: 20px;">3D Rendering Methods for Babylon.js</h2>

            <!-- Method 1: ExtrudeShape -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Method 1: SVG Path Extrusion</h3>
                    <span class="method-badge badge-recommended">Recommended</span>
                </div>
                <p class="method-description">
                    Convert SVG paths to Babylon.js Vector3 points and extrude into 3D geometry.
                </p>

                <div class="input-group">
                    <label>SVG Path</label>
                    <textarea id="extrude-path" placeholder="M0,0 L100,0 L100,100 L0,100 Z">M50,0 L100,50 L50,100 L0,50 Z</textarea>
                </div>

                <div class="input-group">
                    <label>Extrusion Depth</label>
                    <input type="range" id="extrude-depth" min="1" max="50" value="10">
                    <span id="depth-value">10</span>
                </div>

                <button class="btn" onclick="renderExtrusion()">üéÆ Render 3D</button>

                <div id="extrude-canvas" class="demo-area" style="min-height: 400px; background: #000;">
                    <canvas id="babylonCanvas1" style="width: 100%; height: 400px;"></canvas>
                </div>

                <div class="code-block">// Babylon.js Implementation
function svgPathToExtrusion(svgPath, depth, scene) {
    // Parse SVG path to points
    const pathCommands = parseSVG(svgPath);
    
    // Convert to Babylon.js Vector3 array
    const points = [];
    pathCommands.forEach(cmd => {
        if (cmd.x !== undefined) {
            // Normalize coordinates (SVG to 3D space)
            points.push(new BABYLON.Vector3(
                cmd.x / 50 - 1,  // Center and scale
                cmd.y / 50 - 1,
                0
            ));
        }
    });
    
    // Create extrusion path (straight line for depth)
    const extrusionPath = [
        new BABYLON.Vector3(0, 0, 0),
        new BABYLON.Vector3(0, 0, depth)
    ];
    
    // Extrude the shape
    const extruded = BABYLON.MeshBuilder.ExtrudeShape("deviceIcon", {
        shape: points,
        path: extrusionPath,
        cap: BABYLON.Mesh.CAP_ALL,
        sideOrientation: BABYLON.Mesh.DOUBLESIDE
    }, scene);
    
    // Material
    const material = new BABYLON.StandardMaterial("iconMat", scene);
    material.diffuseColor = new BABYLON.Color3(0.2, 0.5, 0.8);
    material.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
    extruded.material = material;
    
    return extruded;
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>Full control over geometry</li>
                            <li>Lightweight</li>
                            <li>Real-time editable</li>
                            <li>Perfect for logos/icons</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons</h4>
                        <ul>
                            <li>Simple depth only</li>
                            <li>No complex 3D features</li>
                            <li>Manual path parsing needed</li>
                            <li>Bezier curves require conversion</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Method 2: CSG Operations -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Method 2: CSG (Constructive Solid Geometry)</h3>
                    <span class="method-badge badge-advanced">Advanced</span>
                </div>
                <p class="method-description">
                    Combine primitive shapes using boolean operations for complex device models.
                </p>

                <button class="btn" onclick="renderCSG()">üéÆ Render CSG Example</button>

                <div id="csg-canvas" class="demo-area" style="min-height: 400px; background: #000;">
                    <canvas id="babylonCanvas2" style="width: 100%; height: 400px;"></canvas>
                </div>

                <div class="code-block">// Babylon.js CSG Implementation
function createDeviceWithCSG(scene) {
    // Create main chassis (box)
    const chassis = BABYLON.MeshBuilder.CreateBox("chassis", {
        width: 4,
        height: 1,
        depth: 2
    }, scene);
    
    // Create port cutouts
    const port = BABYLON.MeshBuilder.CreateBox("port", {
        width: 0.3,
        height: 0.2,
        depth: 0.5
    }, scene);
    port.position.x = -1.5;
    
    // Convert to CSG
    let deviceCSG = BABYLON.CSG.FromMesh(chassis);
    const portCSG = BABYLON.CSG.FromMesh(port);
    
    // Boolean subtract for ports
    for (let i = 0; i < 8; i++) {
        const p = port.clone();
        p.position.x = -1.5 + (i * 0.4);
        const pCSG = BABYLON.CSG.FromMesh(p);
        deviceCSG = deviceCSG.subtract(pCSG);
        p.dispose();
    }
    
    // Add ventilation (subtract cylinders)
    const vent = BABYLON.MeshBuilder.CreateCylinder("vent", {
        diameter: 0.1,
        height: 0.6
    }, scene);
    vent.rotation.z = Math.PI / 2;
    vent.position.y = 0.3;
    
    for (let i = 0; i < 10; i++) {
        const v = vent.clone();
        v.position.x = -1.5 + (i * 0.3);
        const vCSG = BABYLON.CSG.FromMesh(v);
        deviceCSG = deviceCSG.subtract(vCSG);
        v.dispose();
    }
    
    // Convert back to mesh
    const finalDevice = deviceCSG.toMesh("device", null, scene);
    
    // Cleanup
    chassis.dispose();
    port.dispose();
    vent.dispose();
    
    // Material
    const mat = new BABYLON.StandardMaterial("deviceMat", scene);
    mat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
    mat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
    finalDevice.material = mat;
    
    return finalDevice;
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>Complex geometries possible</li>
                            <li>Realistic device details</li>
                            <li>Ports, vents, features</li>
                            <li>Parametric modeling</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons</h4>
                        <ul>
                            <li>Performance intensive</li>
                            <li>Complex code for detailed models</li>
                            <li>Not suitable for many devices</li>
                            <li>Requires 3D modeling knowledge</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Method 3: AI 2D to 3D -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Method 3: AI-Powered Image to 3D</h3>
                    <span class="method-badge badge-experimental">Experimental</span>
                </div>
                <p class="method-description">
                    Use AI services to generate 3D models from 2D icon images automatically.
                </p>

                <div class="input-group">
                    <label>AI Service</label>
                    <select id="ai-service">
                        <option value="meshy">Meshy AI</option>
                        <option value="csm">CSM.ai</option>
                        <option value="alpha3d">Alpha3D</option>
                        <option value="spline">Spline AI</option>
                    </select>
                </div>

                <div class="input-group">
                    <label>Upload 2D Icon</label>
                    <input type="file" id="ai-input" accept="image/*">
                </div>

                <button class="btn" onclick="generateAI3D()">ü§ñ Generate 3D Model</button>

                <div id="ai-result" class="demo-area" style="display: none;">
                    <p>AI-generated model will appear here (requires API key)</p>
                </div>

                <div class="code-block">// AI Service Integration
async function generate3DWithAI(imageFile, service = 'meshy') {
    const formData = new FormData();
    formData.append('image', imageFile);
    formData.append('style', 'network-device');
    
    // Meshy AI example
    if (service === 'meshy') {
        const response = await fetch('https://api.meshy.ai/v1/image-to-3d', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${MESHY_API_KEY}`
            },
            body: formData
        });
        
        const task = await response.json();
        
        // Poll for completion
        let model;
        while (true) {
            const status = await fetch(`https://api.meshy.ai/v1/tasks/${task.id}`, {
                headers: { 'Authorization': `Bearer ${MESHY_API_KEY}` }
            });
            const data = await status.json();
            
            if (data.status === 'COMPLETED') {
                model = data.model_url;
                break;
            }
            await new Promise(r => setTimeout(r, 5000));
        }
        
        return model; // GLB/OBJ URL
    }
}

// Load into Babylon.js
async function loadAIModel(modelUrl, scene) {
    const result = await BABYLON.SceneLoader.ImportMeshAsync(
        "",
        modelUrl,
        "",
        scene
    );
    
    return result.meshes[0];
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>Fully automated</li>
                            <li>Realistic depth perception</li>
                            <li>Complex geometry from 2D</li>
                            <li>No 3D modeling skills needed</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons</h4>
                        <ul>
                            <li>Expensive API costs</li>
                            <li>Unpredictable results</li>
                            <li>Internet dependency</li>
                            <li>Processing time (30s-2min)</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Method 4: Normal Map Billboards -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Method 4: Normal Map + Displacement</h3>
                    <span class="method-badge badge-recommended">Performance</span>
                </div>
                <p class="method-description">
                    Use SVG as texture on plane with normal mapping for pseudo-3D effect.
                </p>

                <button class="btn" onclick="renderNormalMap()">üéÆ Render Billboard</button>

                <div id="normal-canvas" class="demo-area" style="min-height: 400px; background: #000;">
                    <canvas id="babylonCanvas3" style="width: 100%; height: 400px;"></canvas>
                </div>

                <div class="code-block">// Babylon.js Normal Map Implementation
function createNormalMappedIcon(svgUrl, scene) {
    // Create plane
    const plane = BABYLON.MeshBuilder.CreatePlane("iconPlane", {
        width: 2,
        height: 2
    }, scene);
    
    // Convert SVG to texture
    const material = new BABYLON.PBRMaterial("iconMat", scene);
    
    // Albedo (color) from SVG
    material.albedoTexture = new BABYLON.Texture(svgUrl, scene);
    
    // Generate normal map from SVG (for depth illusion)
    // In production, use actual normal map generation
    material.bumpTexture = new BABYLON.Texture(svgUrl, scene);
    material.bumpTexture.level = 0.5;
    
    // Slight displacement for 3D effect
    material.useParallax = true;
    material.useParallaxOcclusion = true;
    material.parallaxScaleBias = 0.1;
    
    // Metallic/roughness for realism
    material.metallic = 0.3;
    material.roughness = 0.7;
    
    plane.material = material;
    
    // Billboard mode (always face camera)
    plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
    
    return plane;
}

// For large topologies with hundreds of devices
function createOptimizedBillboards(devices, scene) {
    const instances = [];
    const basePlane = BABYLON.MeshBuilder.CreatePlane("base", { size: 1 }, scene);
    
    devices.forEach(device => {
        const instance = basePlane.createInstance(device.id);
        instance.position = new BABYLON.Vector3(device.x, device.y, device.z);
        instances.push(instance);
    });
    
    return instances;
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>Extremely lightweight</li>
                            <li>Perfect for large networks</li>
                            <li>Always visible (billboards)</li>
                            <li>Easy to implement</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons</h4>
                        <ul>
                            <li>Not true 3D</li>
                            <li>Same view from all angles</li>
                            <li>Limited depth effect</li>
                            <li>Requires normal map generation</li>
                        </ul>
                    </div>
                </div>
            </div>

            <!-- Method 5: Hybrid Approach -->
            <div class="method-card">
                <div class="method-header">
                    <h3 class="method-title">Method 5: Hybrid SVG + Primitives</h3>
                    <span class="method-badge badge-recommended">Balanced</span>
                </div>
                <p class="method-description">
                    Combine extruded SVG front face with primitive 3D body for best of both worlds.
                </p>

                <button class="btn" onclick="renderHybrid()">üéÆ Render Hybrid Model</button>

                <div id="hybrid-canvas" class="demo-area" style="min-height: 400px; background: #000;">
                    <canvas id="babylonCanvas4" style="width: 100%; height: 400px;"></canvas>
                </div>

                <div class="code-block">// Babylon.js Hybrid Implementation
function createHybridDevice(svgPath, scene) {
    // Parse SVG to points
    const iconPoints = parseSVGToPoints(svgPath);
    
    // Normalize to unit square
    const normalized = normalizePoints(iconPoints, 1.5);
    
    // Create thin extrusion for front face (logo/icon)
    const frontFace = BABYLON.MeshBuilder.ExtrudeShape("front", {
        shape: normalized,
        path: [
            new BABYLON.Vector3(0, 0, 0),
            new BABYLON.Vector3(0, 0, 0.1)
        ],
        cap: BABYLON.Mesh.CAP_ALL
    }, scene);
    
    // Create 3D body (box representing device chassis)
    const body = BABYLON.MeshBuilder.CreateBox("body", {
        width: 2,
        height: 2,
        depth: 1
    }, scene);
    
    // Position front face on front of body
    frontFace.position.z = 0.5 + 0.05; // Half depth + extrusion
    
    // Create parent-child relationship
    frontFace.parent = body;
    
    // Materials
    const bodyMat = new BABYLON.StandardMaterial("bodyMat", scene);
    bodyMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
    bodyMat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
    body.material = bodyMat;
    
    const logoMat = new BABYLON.StandardMaterial("logoMat", scene);
    logoMat.diffuseColor = new BABYLON.Color3(0.1, 0.5, 0.8);
    logoMat.emissiveColor = new BABYLON.Color3(0.05, 0.1, 0.2);
    frontFace.material = logoMat;
    
    // Add ports/LEDs
    addPortDetails(body, scene);
    
    return body;
}

function addPortDetails(device, scene) {
    // Add ethernet ports
    for (let i = 0; i < 8; i++) {
        const port = BABYLON.MeshBuilder.CreateBox("port", {
            width: 0.15,
            height: 0.1,
            depth: 0.2
        }, scene);
        port.position.x = -0.7 + (i * 0.2);
        port.position.y = -0.7;
        port.position.z = 0.4;
        port.parent = device;
        
        const portMat = new BABYLON.StandardMaterial("portMat", scene);
        portMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
        port.material = portMat;
    }
    
    // Add status LEDs
    for (let i = 0; i < 3; i++) {
        const led = BABYLON.MeshBuilder.CreateSphere("led", {
            diameter: 0.05
        }, scene);
        led.position.x = -0.8 + (i * 0.2);
        led.position.y = 0.8;
        led.position.z = 0.5;
        led.parent = device;
        
        const ledMat = new BABYLON.StandardMaterial("ledMat", scene);
        ledMat.diffuseColor = new BABYLON.Color3(0, 1, 0);
        ledMat.emissiveColor = new BABYLON.Color3(0, 0.5, 0);
        led.material = ledMat;
    }
}</div>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Pros</h4>
                        <ul>
                            <li>Recognizable vendor logos</li>
                            <li>True 3D depth</li>
                            <li>Reasonable performance</li>
                            <li>Detailed yet efficient</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons</h4>
                        <ul>
                            <li>More complex implementation</li>
                            <li>Higher poly count than billboards</li>
                            <li>Requires both SVG and 3D modeling</li>
                            <li>Manual detail placement</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>

        <!-- COMPARISON TAB -->
        <div id="comparison" class="tab-content">
            <h2 style="margin-bottom: 20px;">Method Comparison & Recommendations</h2>

            <div class="method-card">
                <h3>Icon Finding Methods - Comparison</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Accuracy</th>
                            <th>Automation</th>
                            <th>Maintenance</th>
                            <th>Best For</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Vendor APIs</strong></td>
                            <td><span class="metric metric-high">High</span></td>
                            <td><span class="metric metric-high">High</span></td>
                            <td><span class="metric metric-medium">Medium</span></td>
                            <td>Production, brand accuracy</td>
                        </tr>
                        <tr>
                            <td><strong>MAC OUI Mapping</strong></td>
                            <td><span class="metric metric-high">High</span></td>
                            <td><span class="metric metric-high">Very High</span></td>
                            <td><span class="metric metric-medium">Medium</span></td>
                            <td>Network discovery integration</td>
                        </tr>
                        <tr>
                            <td><strong>Visio Extraction</strong></td>
                            <td><span class="metric metric-high">High</span></td>
                            <td><span class="metric metric-low">Low</span></td>
                            <td><span class="metric metric-low">Low</span></td>
                            <td>One-time bulk extraction</td>
                        </tr>
                        <tr>
                            <td><strong>Web Scraping</strong></td>
                            <td><span class="metric metric-medium">Medium</span></td>
                            <td><span class="metric metric-medium">Medium</span></td>
                            <td><span class="metric metric-low">Low</span></td>
                            <td>Latest product images</td>
                        </tr>
                        <tr>
                            <td><strong>Generic Icons</strong></td>
                            <td><span class="metric metric-low">Low</span></td>
                            <td><span class="metric metric-high">High</span></td>
                            <td><span class="metric metric-high">High</span></td>
                            <td>Fallback, multi-vendor consistency</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="method-card">
                <h3>SVG Conversion Methods - Comparison</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Quality</th>
                            <th>Speed</th>
                            <th>Setup Complexity</th>
                            <th>Best For</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Potrace</strong></td>
                            <td><span class="metric metric-high">High</span></td>
                            <td><span class="metric metric-high">Fast</span></td>
                            <td><span class="metric metric-medium">Medium</span></td>
                            <td>Batch processing, automation</td>
                        </tr>
                        <tr>
                            <td><strong>Inkscape CLI</strong></td>
                            <td><span class="metric metric-high">Very High</span></td>
                            <td><span class="metric metric-medium">Medium</span></td>
                            <td><span class="metric metric-high">High</span></td>
                            <td>Best quality, multicolor</td>
                        </tr>
                        <tr>
                            <td><strong>Cloudinary API</strong></td>
                            <td><span class="metric metric-high">High</span></td>
                            <td><span class="metric metric-high">Very Fast</span></td>
                            <td><span class="metric metric-low">Low</span></td>
                            <td>Cloud apps, scalability</td>
                        </tr>
                        <tr>
                            <td><strong>SVG Parser</strong></td>
                            <td><span class="metric metric-high">High</span></td>
                            <td><span class="metric metric-high">Very Fast</span></td>
                            <td><span class="metric metric-low">Low</span></td>
                            <td>Existing SVG manipulation</td>
                        </tr>
                        <tr>
                            <td><strong>Visio Extraction</strong></td>
                            <td><span class="metric metric-high">Very High</span></td>
                            <td><span class="metric metric-medium">Medium</span></td>
                            <td><span class="metric metric-high">High</span></td>
                            <td>Official vendor stencils</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="method-card">
                <h3>3D Rendering Methods - Comparison</h3>
                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Visual Quality</th>
                            <th>Performance</th>
                            <th>Implementation</th>
                            <th>Best For</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Extrusion</strong></td>
                            <td><span class="metric metric-medium">Medium</span></td>
                            <td><span class="metric metric-high">Excellent</span></td>
                            <td><span class="metric metric-medium">Medium</span></td>
                            <td>Simple icons, logos</td>
                        </tr>
                        <tr>
                            <td><strong>CSG Operations</strong></td>
                            <td><span class="metric metric-high">High</span></td>
                            <td><span class="metric metric-low">Poor</span></td>
                            <td><span class="metric metric-high">Complex</span></td>
                            <td>Detailed single devices</td>
                        </tr>
                        <tr>
                            <td><strong>AI 2D‚Üí3D</strong></td>
                            <td><span class="metric metric-high">Very High</span></td>
                            <td><span class="metric metric-medium">Medium</span></td>
                            <td><span class="metric metric-low">Easy</span></td>
                            <td>Hero devices, marketing</td>
                        </tr>
                        <tr>
                            <td><strong>Normal Map Billboard</strong></td>
                            <td><span class="metric metric-low">Low</span></td>
                            <td><span class="metric metric-high">Excellent</span></td>
                            <td><span class="metric metric-low">Easy</span></td>
                            <td>Large networks (100+ devices)</td>
                        </tr>
                        <tr>
                            <td><strong>Hybrid SVG+Primitives</strong></td>
                            <td><span class="metric metric-high">High</span></td>
                            <td><span class="metric metric-medium">Good</span></td>
                            <td><span class="metric metric-medium">Medium</span></td>
                            <td>Production apps, balance</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <div class="method-card">
                <h3>üéØ Recommended Workflow for Your Network Topology App</h3>
                
                <div style="background: rgba(33, 128, 141, 0.1); padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <h4 style="margin-top: 0;">Production-Ready Pipeline</h4>
                    
                    <h5>Phase 1: Icon Discovery (Hybrid Approach)</h5>
                    <ol style="color: var(--color-text-secondary); line-height: 1.8;">
                        <li><strong>Primary:</strong> MAC OUI ‚Üí Vendor API lookup (automated from your Fortinet/Meraki APIs)</li>
                        <li><strong>Secondary:</strong> Device model string matching to icon repository</li>
                        <li><strong>Fallback:</strong> Generic device type icons</li>
                    </ol>

                    <h5>Phase 2: SVG Conversion (Based on Source)</h5>
                    <ol style="color: var(--color-text-secondary); line-height: 1.8;">
                        <li><strong>If vendor provides SVG:</strong> Use directly with SVG Parser for optimization</li>
                        <li><strong>If PNG/raster only:</strong> Potrace (Node.js) for batch conversion</li>
                        <li><strong>For official Visio stencils:</strong> One-time extraction to build icon library</li>
                    </ol>

                    <h5>Phase 3: 3D Rendering (Scale-Based)</h5>
                    <ol style="color: var(--color-text-secondary); line-height: 1.8;">
                        <li><strong>Small networks (&lt;50 devices):</strong> Hybrid SVG + Primitives</li>
                        <li><strong>Medium networks (50-200):</strong> Simple Extrusion</li>
                        <li><strong>Large networks (200+):</strong> Normal Map Billboards with LOD</li>
                        <li><strong>Hero/featured devices:</strong> AI-generated high-detail models</li>
                    </ol>
                </div>

                <div class="code-block">// Complete Pipeline Example
class NetworkTopology3D {
    constructor(scene) {
        this.scene = scene;
        this.iconCache = new Map();
        this.deviceMeshes = new Map();
    }
    
    async addDevice(deviceData) {
        // Phase 1: Find Icon
        const icon = await this.findIcon(deviceData);
        
        // Phase 2: Ensure SVG
        const svg = await this.ensureSVG(icon);
        
        // Phase 3: Create 3D Representation
        const mesh = this.create3DDevice(svg, deviceData);
        
        // Position in topology
        mesh.position = new BABYLON.Vector3(
            deviceData.x,
            deviceData.y,
            deviceData.z
        );
        
        this.deviceMeshes.set(deviceData.id, mesh);
        return mesh;
    }
    
    async findIcon(device) {
        // MAC OUI lookup
        const vendor = await this.lookupMAC(device.mac);
        
        // Try vendor API
        try {
            return await this.queryVendorAPI(vendor, device.model);
        } catch {
            // Fallback to generic
            return this.getGenericIcon(device.type);
        }
    }
    
    async ensureSVG(icon) {
        if (icon.format === 'svg') return icon.data;
        
        // Cache check
        if (this.iconCache.has(icon.url)) {
            return this.iconCache.get(icon.url);
        }
        
        // Convert with Potrace
        const svg = await this.convertToSVG(icon.url);
        this.iconCache.set(icon.url, svg);
        return svg;
    }
    
    create3DDevice(svg, device) {
        const count = this.deviceMeshes.size;
        
        // Scale-based rendering
        if (count < 50) {
            return this.createHybridDevice(svg);
        } else if (count < 200) {
            return this.createExtrudedDevice(svg);
        } else {
            return this.createBillboard(svg);
        }
    }
}</div>
            </div>

            <div class="method-card">
                <h3>üí° Key Takeaways</h3>
                <div class="grid-2">
                    <div>
                        <h4>Icon Finding</h4>
                        <ul style="color: var(--color-text-secondary);">
                            <li><strong>Best:</strong> MAC OUI + Vendor API combo</li>
                            <li><strong>Most Automated:</strong> Network discovery integration</li>
                            <li><strong>Highest Quality:</strong> Official vendor libraries</li>
                            <li><strong>Always Have:</strong> Generic fallback icons</li>
                        </ul>
                    </div>
                    <div>
                        <h4>SVG Conversion</h4>
                        <ul style="color: var(--color-text-secondary);">
                            <li><strong>Best Quality:</strong> Inkscape CLI or Visio extraction</li>
                            <li><strong>Best Performance:</strong> Potrace or Cloudinary</li>
                            <li><strong>Most Flexible:</strong> SVG Parser libraries</li>
                            <li><strong>Cloud Apps:</strong> Cloudinary API</li>
                        </ul>
                    </div>
                </div>
                <div class="grid-2" style="margin-top: 16px;">
                    <div>
                        <h4>3D Rendering</h4>
                        <ul style="color: var(--color-text-secondary);">
                            <li><strong>Best Balance:</strong> Hybrid SVG + Primitives</li>
                            <li><strong>Best Performance:</strong> Billboards with LOD</li>
                            <li><strong>Best Quality:</strong> AI-generated models</li>
                            <li><strong>Most Control:</strong> Extrusion with custom materials</li>
                        </ul>
                    </div>
                    <div>
                        <h4>Your Fortinet/Meraki Stack</h4>
                        <ul style="color: var(--color-text-secondary);">
                            <li>Use FortiGate/Meraki APIs for device discovery</li>
                            <li>Extract MAC + model from API responses</li>
                            <li>icons.fortinet.com for Fortinet devices</li>
                            <li>Scale rendering based on network size</li>
                        </ul>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script>
        // Restaurant device lookup functionality
        async function lookupDevice() {
            const macInput = document.getElementById('mac-input');
            const hostnameInput = document.getElementById('hostname-input');
            const resultDiv = document.getElementById('device-result');
            
            const mac = macInput.value.trim();
            const hostname = hostnameInput.value.trim();
            
            if (!mac) {
                alert('Please enter a MAC address');
                return;
            }
            
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = '<div class="status-message status-info">Looking up device...</div>';
            
            try {
                const response = await fetch(`/api/devices/lookup/${mac}`);
                if (response.ok) {
                    const device = await response.json();
                    displayDeviceResult(device, hostname);
                } else {
                    throw new Error('API lookup failed');
                }
            } catch (error) {
                // Fallback to demo data
                const device = getDemoDeviceData(mac, hostname);
                displayDeviceResult(device, hostname);
            }
        }
        
        function getDemoDeviceData(mac, hostname) {
            const deviceMap = {
                '00:0C:F1': { vendor: 'Ingenico', type: 'POS Register/Cash Terminal', pos: 'Clover (Ingenico)', model: 'pos_register.obj' },
                'AC:BC:32': { vendor: 'Square (Block)', type: 'POS Register/Cash Terminal', pos: 'Square (Block Inc)', model: 'square_terminal.obj' },
                'B8:27:EB': { vendor: 'Raspberry Pi Foundation', type: 'Kitchen Display Unit (KDS)', pos: 'Toast', model: 'kitchen_display.obj' },
                '28:CF:E9': { vendor: 'Apple', type: 'POS Tablet/Tabletop Ordering', pos: 'iPad-based POS', model: 'pos_tablet.obj' },
                '00:0D:93': { vendor: 'NCR Corporation', type: 'Kitchen/Receipt Printer', pos: 'NCR Aloha', model: 'kitchen_printer.obj' },
                '44:38:39': { vendor: 'Square', type: 'POS Register/Cash Terminal', pos: 'Square Terminal', model: 'pos_register.obj' },
                '40:4D:55': { vendor: 'Clover Mini', type: 'POS Register/Cash Terminal', pos: 'Clover Mini', model: 'pos_register.obj' },
                '68:72:51': { vendor: 'Clover Flex', type: 'Payment Terminal', pos: 'Clover Flex', model: 'payment_terminal.obj' },
                'DC:A6:32': { vendor: 'Raspberry Pi Trading', type: 'Digital Menu Board', pos: 'Toast', model: 'digital_menu.obj' },
                '90:6C:AC': { vendor: 'Fortinet', type: 'Firewall/UTM', pos: null, model: 'firewall.obj' }
            };
            
            const oui = mac.toUpperCase().substring(0, 8);
            const deviceInfo = deviceMap[oui] || { 
                vendor: 'Unknown', 
                type: 'Unknown Device', 
                pos: null, 
                model: 'generic_device.obj' 
            };
            
            return {
                mac_address: mac,
                vendor: deviceInfo.vendor,
                device_type: deviceInfo.type,
                confidence: 'high',
                model_path: `/static/3d-models/${deviceInfo.model}`,
                pos_system: deviceInfo.pos,
                details: { hostname: hostname }
            };
        }
        
        function displayDeviceResult(device, hostname) {
            const resultDiv = document.getElementById('device-result');
            const confidenceColor = device.confidence === 'high' ? 'var(--color-success)' : 'var(--color-warning)';
            
            resultDiv.innerHTML = `
                <div class="status-message status-success">
                    <strong>‚úÖ Device Identified</strong><br><br>
                    <table style="width: 100%; border-collapse: collapse;">
                        <tr>
                            <td style="padding: 4px; font-weight: bold; width: 120px;">MAC Address:</td>
                            <td style="padding: 4px; font-family: monospace;">${device.mac_address}</td>
                        </tr>
                        <tr>
                            <td style="padding: 4px; font-weight: bold;">Vendor:</td>
                            <td style="padding: 4px;">${device.vendor}</td>
                        </tr>
                        <tr>
                            <td style="padding: 4px; font-weight: bold;">Device Type:</td>
                            <td style="padding: 4px;">${device.device_type}</td>
                        </tr>
                        <tr>
                            <td style="padding: 4px; font-weight: bold;">Confidence:</td>
                            <td style="padding: 4px; color: ${confidenceColor};">${device.confidence}</td>
                        </tr>
                        ${device.pos_system ? `
                        <tr>
                            <td style="padding: 4px; font-weight: bold;">POS System:</td>
                            <td style="padding: 4px;">${device.pos_system}</td>
                        </tr>
                        ` : ''}
                        <tr>
                            <td style="padding: 4px; font-weight: bold;">3D Model:</td>
                            <td style="padding: 4px; font-family: monospace; font-size: 12px;">${device.model_path}</td>
                        </tr>
                        ${hostname ? `
                        <tr>
                            <td style="padding: 4px; font-weight: bold;">Hostname:</td>
                            <td style="padding: 4px;">${hostname}</td>
                        </tr>
                        ` : ''}
                    </table>
                </div>
                <div style="margin-top: 10px; color: var(--color-text-secondary); font-size: 13px;">
                    üí° This device can be visualized in the 3D topology view with vendor-specific shapes and colors.
                </div>
            `;
        }
        
        function testDevice(mac, hostname) {
            document.getElementById('mac-input').value = mac;
            document.getElementById('hostname-input').value = hostname;
            lookupDevice();
        }
        
        function copyCode(textareaId) {
            const textarea = document.getElementById(textareaId);
            navigator.clipboard.writeText(textarea.value).then(() => {
                // Show success feedback
                const button = event.target;
                const originalText = button.innerHTML;
                button.innerHTML = '‚úÖ Copied!';
                button.style.backgroundColor = 'var(--color-success)';
                button.style.color = 'white';
                
                setTimeout(() => {
                    button.innerHTML = originalText;
                    button.style.backgroundColor = '';
                    button.style.color = '';
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy code:', err);
                // Fallback for older browsers
                textarea.select();
                document.execCommand('copy');
            });
        }

        // Tab switching
        function switchTab(tabId) {
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            document.getElementById(tabId).classList.add('active');
            event.target.classList.add('active');
        }

        // Range slider updates
        document.querySelectorAll('input[type="range"]').forEach(slider => {
            slider.addEventListener('input', (e) => {
                const valueSpan = document.getElementById(e.target.id.replace('-', '-') + '-value') ||
                                document.getElementById(e.target.id.split('-')[0] + '-value');
                if (valueSpan) {
                    valueSpan.textContent = e.target.value;
                }
            });
        });

        // Icon Finding Methods
        function findVendorIcon() {
            const vendor = document.getElementById('vendor-select').value;
            const model = document.getElementById('device-model').value;
            const resultDiv = document.getElementById('vendor-result');
            
            if (!model) {
                alert('Please enter a device model');
                return;
            }
            
            resultDiv.style.display = 'flex';
            resultDiv.innerHTML = `
                <div class="status-message status-success">
                    <strong>Found:</strong> ${vendor} icon for ${model}<br>
                    <small>URL: https://icons.${vendor}.com/${model}.svg</small>
                </div>
                <div style="margin-top: 10px; color: var(--color-text-secondary); font-size: 13px;">
                    In production, this would query the actual ${vendor} API
                </div>
            `;
        }

        function findByMAC() {
            const mac = document.getElementById('mac-address').value;
            const resultDiv = document.getElementById('mac-result');
            
            if (!mac) {
                alert('Please enter a MAC address');
                return;
            }
            
            // Simulate OUI lookup
            const oui = mac.substring(0, 8).toUpperCase();
            const vendors = {
                '00:09:0F': 'Fortinet',
                'F0:9F:C2': 'Cisco Meraki',
                '00:1B:D5': 'Cisco',
                'default': 'Unknown Vendor'
            };
            
            const vendor = vendors[oui] || vendors['default'];
            
            resultDiv.style.display = 'flex';
            document.getElementById('mac-vendor-info').innerHTML = `
                <div class="status-message status-success">
                    <strong>OUI:</strong> ${oui}<br>
                    <strong>Vendor:</strong> ${vendor}<br>
                    <strong>Icon Repository:</strong> ${vendor.toLowerCase().replace(' ', '-')}-icons
                </div>
                <div style="margin-top: 10px; color: var(--color-text-secondary); font-size: 13px;">
                    Next: Query SNMP sysDescr for exact model ‚Üí Map to icon
                </div>
            `;
        }

        function extractVisioIcons() {
            alert('This would parse the uploaded .vsdx file and extract SVG data.\n\nRequires Node.js backend with jszip and xml2js.');
        }

        function scrapeVendorDocs() {
            const url = document.getElementById('scrape-url').value;
            if (!url) {
                alert('Please enter a documentation URL');
                return;
            }
            alert('This would use Puppeteer to scrape images from vendor documentation.\n\nNote: Ensure compliance with vendor ToS.');
        }

        function getGenericIcon() {
            const type = document.getElementById('device-type').value;
            const resultDiv = document.getElementById('generic-result');
            
            const icons = {
                'router': 'üîÄ',
                'switch': 'üîå',
                'firewall': 'üõ°Ô∏è',
                'ap': 'üì°',
                'server': 'üñ•Ô∏è'
            };
            
            resultDiv.style.display = 'flex';
            document.getElementById('generic-icon').innerHTML = `
                <div style="font-size: 72px;">${icons[type]}</div>
                <div class="status-message status-success" style="margin-top: 16px;">
                    Generic ${type} icon<br>
                    <small>In production: Use SVG from icon library</small>
                </div>
            `;
        }

        // SVG Conversion Methods
        function convertWithPotrace() {
            alert('Potrace conversion requires Node.js backend.\n\nSee code example for implementation.');
        }

        function convertWithInkscape() {
            alert('Inkscape conversion requires Inkscape CLI installed.\n\nSee code example for implementation.');
        }

        function convertWithCloudinary() {
            const cloudName = document.getElementById('cloud-name').value;
            if (!cloudName) {
                alert('Please enter your Cloudinary cloud name');
                return;
            }
            
            const detail = document.getElementById('vectorize-detail').value;
            const colors = document.getElementById('vectorize-colors').value;
            
            const resultDiv = document.getElementById('cloudinary-result');
            resultDiv.style.display = 'flex';
            document.getElementById('cloudinary-output').innerHTML = `
                <div class="status-message status-success">
                    <strong>Generated URL:</strong><br>
                    <code style="font-size: 11px;">https://res.cloudinary.com/${cloudName}/image/upload/e_vectorize:colors:${colors}:detail:${detail}/device-icon.svg</code>
                </div>
                <div style="margin-top: 10px; color: var(--color-text-secondary); font-size: 13px;">
                    Upload image to Cloudinary first, then use transformation URL
                </div>
            `;
        }

        function parseSVGPath() {
            const path = document.getElementById('svg-path-input').value;
            if (!path) {
                alert('Please enter SVG path data');
                return;
            }
            
            const resultDiv = document.getElementById('parser-result');
            resultDiv.style.display = 'flex';
            document.getElementById('parsed-output').innerHTML = `
                <div class="status-message status-success">
                    Path parsed successfully<br>
                    <small>Commands: ${path.match(/[MLHVCSQTAZ]/gi)?.length || 0}</small>
                </div>
                <div style="margin-top: 10px; color: var(--color-text-secondary); font-size: 13px;">
                    Use svg-path-parser library for production implementation
                </div>
            `;
        }

        // 3D Rendering Methods
        let scenes = {};

        function initBabylon(canvasId) {
            const canvas = document.getElementById(canvasId);
            const engine = new BABYLON.Engine(canvas, true);
            const scene = new BABYLON.Scene(engine);
            
            scene.clearColor = new BABYLON.Color4(0.1, 0.1, 0.1, 1);
            
            const camera = new BABYLON.ArcRotateCamera("camera", 
                -Math.PI / 2, Math.PI / 2.5, 5, 
                new BABYLON.Vector3(0, 0, 0), scene);
            camera.attachControl(canvas, true);
            
            const light = new BABYLON.HemisphericLight("light", 
                new BABYLON.Vector3(1, 1, 0), scene);
            
            engine.runRenderLoop(() => scene.render());
            window.addEventListener('resize', () => engine.resize());
            
            return scene;
        }

        function renderExtrusion() {
            const canvas = document.getElementById('babylonCanvas1');
            if (!scenes['canvas1']) {
                scenes['canvas1'] = initBabylon('babylonCanvas1');
            }
            
            const scene = scenes['canvas1'];
            scene.meshes.forEach(m => { if (m.name !== 'camera') m.dispose(); });
            
            // Simple diamond shape
            const points = [
                new BABYLON.Vector3(0, 1, 0),
                new BABYLON.Vector3(1, 0, 0),
                new BABYLON.Vector3(0, -1, 0),
                new BABYLON.Vector3(-1, 0, 0),
                new BABYLON.Vector3(0, 1, 0)
            ];
            
            const depth = parseFloat(document.getElementById('extrude-depth').value) / 10;
            
            const path = [
                new BABYLON.Vector3(0, 0, 0),
                new BABYLON.Vector3(0, 0, depth)
            ];
            
            const extrusion = BABYLON.MeshBuilder.ExtrudeShape("icon", {
                shape: points,
                path: path,
                cap: BABYLON.Mesh.CAP_ALL
            }, scene);
            
            const mat = new BABYLON.StandardMaterial("mat", scene);
            mat.diffuseColor = new BABYLON.Color3(0.2, 0.6, 0.9);
            mat.specularColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            extrusion.material = mat;
        }

        function renderCSG() {
            const canvas = document.getElementById('babylonCanvas2');
            if (!scenes['canvas2']) {
                scenes['canvas2'] = initBabylon('babylonCanvas2');
            }
            
            const scene = scenes['canvas2'];
            scene.meshes.forEach(m => { if (m.name !== 'camera') m.dispose(); });
            
            // Device chassis
            const chassis = BABYLON.MeshBuilder.CreateBox("chassis", {
                width: 3, height: 0.5, depth: 1.5
            }, scene);
            
            let deviceCSG = BABYLON.CSG.FromMesh(chassis);
            
            // Add ports
            for (let i = 0; i < 8; i++) {
                const port = BABYLON.MeshBuilder.CreateBox("port", {
                    width: 0.2, height: 0.15, depth: 0.3
                }, scene);
                port.position.x = -1.2 + (i * 0.35);
                port.position.z = 0.6;
                
                const portCSG = BABYLON.CSG.FromMesh(port);
                deviceCSG = deviceCSG.subtract(portCSG);
                port.dispose();
            }
            
            const device = deviceCSG.toMesh("device", null, scene);
            chassis.dispose();
            
            const mat = new BABYLON.StandardMaterial("mat", scene);
            mat.diffuseColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            mat.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            device.material = mat;
        }

        function generateAI3D() {
            alert('AI 3D generation requires API integration.\n\nSupported services:\n- Meshy AI\n- CSM.ai\n- Alpha3D\n- Spline AI\n\nSee code example for implementation.');
        }

        function renderNormalMap() {
            const canvas = document.getElementById('babylonCanvas3');
            if (!scenes['canvas3']) {
                scenes['canvas3'] = initBabylon('babylonCanvas3');
            }
            
            const scene = scenes['canvas3'];
            scene.meshes.forEach(m => { if (m.name !== 'camera') m.dispose(); });
            
            const plane = BABYLON.MeshBuilder.CreatePlane("billboard", {
                width: 2, height: 2
            }, scene);
            
            const mat = new BABYLON.StandardMaterial("mat", scene);
            mat.diffuseColor = new BABYLON.Color3(0.2, 0.6, 0.9);
            mat.emissiveColor = new BABYLON.Color3(0.1, 0.2, 0.3);
            plane.material = mat;
            
            // Billboard mode
            plane.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;
        }

        function renderHybrid() {
            const canvas = document.getElementById('babylonCanvas4');
            if (!scenes['canvas4']) {
                scenes['canvas4'] = initBabylon('babylonCanvas4');
            }
            
            const scene = scenes['canvas4'];
            scene.meshes.forEach(m => { if (m.name !== 'camera') m.dispose(); });
            
            // Device body
            const body = BABYLON.MeshBuilder.CreateBox("body", {
                width: 2.5, height: 0.4, depth: 1.5
            }, scene);
            
            const bodyMat = new BABYLON.StandardMaterial("bodyMat", scene);
            bodyMat.diffuseColor = new BABYLON.Color3(0.2, 0.2, 0.2);
            bodyMat.specularColor = new BABYLON.Color3(0.4, 0.4, 0.4);
            body.material = bodyMat;
            
            // Logo (extruded icon)
            const logoPoints = [
                new BABYLON.Vector3(-0.3, 0.3, 0),
                new BABYLON.Vector3(0.3, 0.3, 0),
                new BABYLON.Vector3(0.3, -0.3, 0),
                new BABYLON.Vector3(-0.3, -0.3, 0),
                new BABYLON.Vector3(-0.3, 0.3, 0)
            ];
            
            const logo = BABYLON.MeshBuilder.ExtrudeShape("logo", {
                shape: logoPoints,
                path: [new BABYLON.Vector3(0, 0, 0), new BABYLON.Vector3(0, 0, 0.05)],
                cap: BABYLON.Mesh.CAP_ALL
            }, scene);
            
            logo.position.z = 0.75 + 0.025;
            logo.parent = body;
            
            const logoMat = new BABYLON.StandardMaterial("logoMat", scene);
            logoMat.diffuseColor = new BABYLON.Color3(0.1, 0.5, 0.9);
            logoMat.emissiveColor = new BABYLON.Color3(0.05, 0.1, 0.2);
            logo.material = logoMat;
            
            // Ports
            for (let i = 0; i < 8; i++) {
                const port = BABYLON.MeshBuilder.CreateBox("port", {
                    width: 0.15, height: 0.1, depth: 0.15
                }, scene);
                port.position.x = -0.9 + (i * 0.25);
                port.position.y = -0.15;
                port.position.z = 0.65;
                port.parent = body;
                
                const portMat = new BABYLON.StandardMaterial("portMat", scene);
                portMat.diffuseColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                port.material = portMat;
            }
            
            // LEDs
            for (let i = 0; i < 3; i++) {
                const led = BABYLON.MeshBuilder.CreateSphere("led", { diameter: 0.05 }, scene);
                led.position.x = -0.8 + (i * 0.2);
                led.position.y = 0.15;
                led.position.z = 0.75;
                led.parent = body;
                
                const ledMat = new BABYLON.StandardMaterial("ledMat", scene);
                ledMat.diffuseColor = new BABYLON.Color3(0, 1, 0);
                ledMat.emissiveColor = new BABYLON.Color3(0, 0.5, 0);
                led.material = ledMat;
            }
        }
    </script>
</body>
</html>

